<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust Rand Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Extended documentation for Rust's Rand lib">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="guide-start.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="crates.html"><strong aria-hidden="true">2.</strong> Crates and features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="crates-rand.html"><strong aria-hidden="true">2.1.</strong> Rand and co</a></li><li class="chapter-item expanded "><a href="crates-gen.html"><strong aria-hidden="true">2.2.</strong> Random generators</a></li></ol></li><li class="chapter-item expanded "><a href="guide.html"><strong aria-hidden="true">3.</strong> Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guide-data.html"><strong aria-hidden="true">3.1.</strong> Random data</a></li><li class="chapter-item expanded "><a href="guide-gen.html"><strong aria-hidden="true">3.2.</strong> Types of generators</a></li><li class="chapter-item expanded "><a href="guide-rngs.html"><strong aria-hidden="true">3.3.</strong> Our RNGs</a></li><li class="chapter-item expanded "><a href="guide-seeding.html"><strong aria-hidden="true">3.4.</strong> Seeding RNGs</a></li><li class="chapter-item expanded "><a href="guide-values.html"><strong aria-hidden="true">3.5.</strong> Random values</a></li><li class="chapter-item expanded "><a href="guide-dist.html"><strong aria-hidden="true">3.6.</strong> Random distributions</a></li><li class="chapter-item expanded "><a href="guide-seq.html"><strong aria-hidden="true">3.7.</strong> Sequences</a></li><li class="chapter-item expanded "><a href="guide-err.html"><strong aria-hidden="true">3.8.</strong> Error handling</a></li></ol></li><li class="chapter-item expanded "><a href="portability.html"><strong aria-hidden="true">4.</strong> Portability</a></li><li class="chapter-item expanded "><a href="update.html"><strong aria-hidden="true">5.</strong> Updating</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="update-0.5.html"><strong aria-hidden="true">5.1.</strong> Updating to 0.5</a></li><li class="chapter-item expanded "><a href="update-0.6.html"><strong aria-hidden="true">5.2.</strong> Updating to 0.6</a></li><li class="chapter-item expanded "><a href="update-0.7.html"><strong aria-hidden="true">5.3.</strong> Updating to 0.7</a></li><li class="chapter-item expanded "><a href="update-0.8.html"><strong aria-hidden="true">5.4.</strong> Updating to 0.8</a></li></ol></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">6.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contrib-doc.html"><strong aria-hidden="true">6.1.</strong> Documentation</a></li><li class="chapter-item expanded "><a href="contrib-scope.html"><strong aria-hidden="true">6.2.</strong> Scope</a></li><li class="chapter-item expanded "><a href="contrib-test.html"><strong aria-hidden="true">6.3.</strong> Testing</a></li><li class="chapter-item expanded "><a href="contrib-bench.html"><strong aria-hidden="true">6.4.</strong> Benchmarks</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Rust Rand Book</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#the-rust-rand-book" id="the-rust-rand-book">The Rust Rand Book</a></h1>
<p>This is the extended documentation for Rust's <strong>Rand</strong>om number library.</p>
<p>This book contains:</p>
<ol>
<li><a href="guide-start.html">Getting Started</a></li>
<li>An overview of <a href="crates.html">crates and functionality</a></li>
<li>The <a href="guide.html">Users' Guide</a></li>
<li>Notes on <a href="portability.html">Portability and Reproducibility</a>.
(Read this if you want reproducibility across builds.)</li>
<li><a href="update.html">Updating guides</a></li>
<li><a href="contributing.html">Contributor's guide</a></li>
</ol>
<p>Outside this book, you may want:</p>
<ul>
<li><a href="https://docs.rs/rand/">API reference for the latest release</a></li>
<li><a href="https://rust-random.github.io/rand/">API reference for the master branch</a></li>
<li><a href="https://github.com/rust-random/rand/">The Rand repository</a></li>
<li><a href="https://github.com/rust-random/book/">The Book source</a></li>
</ul>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>Below we list a short example. For more, please refer to the <a href="https://rust-random.github.io/rand/rand/index.html">API documentation</a>
or the <a href="guide.html">guide</a>.</p>
<p>Lets kick things off with an example (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=7792ed032694bc558ca229be71a7783a">playground link</a>):</p>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">extern crate rand;
</span>// import commonly used items from the prelude:
use rand::prelude::*;

fn main() {
    // We can use random() immediately. It can produce values of many common types:
    let x: u8 = random();
    println!(&quot;{}&quot;, x);

    if random() { // generates a boolean
        println!(&quot;Heads!&quot;);
    }

    // If we want to be a bit more explicit (and a little more efficient) we can
    // make a handle to the thread-local generator:
    let mut rng = thread_rng();
    if rng.gen() { // random bool
        let x: f64 = rng.gen(); // random number in range [0, 1)
        let y = rng.gen_range(-10.0..10.0);
        println!(&quot;x is: {}&quot;, x);
        println!(&quot;y is: {}&quot;, y);
    }

    println!(&quot;Die roll: {}&quot;, rng.gen_range(1..=6));
    println!(&quot;Number from 0 to 9: {}&quot;, rng.gen_range(0..10));
    
    // Sometimes it's useful to use distributions directly:
    let distr = rand::distributions::Uniform::new_inclusive(1, 100);
    let mut nums = [0i32; 3];
    for x in &amp;mut nums {
        *x = rng.sample(distr);
    }
    println!(&quot;Some numbers: {:?}&quot;, nums);

    // We can also interact with iterators and slices:
    let arrows_iter = &quot;➡⬈⬆⬉⬅⬋⬇⬊&quot;.chars();
    println!(&quot;Lets go in this direction: {}&quot;, arrows_iter.choose(&amp;mut rng).unwrap());
    let mut nums = [1, 2, 3, 4, 5];
    nums.shuffle(&amp;mut rng);
    println!(&quot;I shuffled my {:?}&quot;, nums);
}
</code></pre></pre>
<p>The first thing you may have noticed is that we imported everything from the
<a href="https://rust-random.github.io/rand/rand/prelude/index.html">prelude</a>. This is the lazy way to <code>use</code> rand, and like the
<a href="https://doc.rust-lang.org/std/prelude/index.html">standard library's prelude</a>,
only imports the most common items. If you don't wish to use the prelude,
remember to import the <a href="https://rust-random.github.io/rand/rand/trait.Rng.html"><code>Rng</code></a> trait!</p>
<p>The Rand library automatically initialises a secure, thread-local generator
on demand. This can be accessed via the <a href="https://rust-random.github.io/rand/rand/fn.thread_rng.html"><code>thread_rng</code></a> and <a href="https://rust-random.github.io/rand/rand/fn.random.html"><code>random</code></a> functions.
For more on this topic, see <a href="guide-gen.html">Random generators</a>.</p>
<p>While the <a href="https://rust-random.github.io/rand/rand/fn.random.html"><code>random</code></a> function can only sample values in a <a href="https://rust-random.github.io/rand/rand/distributions/struct.Standard.html"><code>Standard</code></a>
(type-dependent) manner, <a href="https://rust-random.github.io/rand/rand/fn.thread_rng.html"><code>thread_rng</code></a> gives you a handle to a generator.
All generators implement the <a href="https://rust-random.github.io/rand/rand/trait.Rng.html"><code>Rng</code></a> trait, which provides the <a href="https://rust-random.github.io/rand/rand/trait.Rng.html#method.gen"><code>gen</code></a>,
<a href="https://rust-random.github.io/rand/rand/trait.Rng.html#method.gen_range"><code>gen_range</code></a> and <a href="https://rust-random.github.io/rand/rand/trait.Rng.html#method.sample"><code>sample</code></a> methods used above.</p>
<p>Rand provides functionality on iterators and slices via two more traits,
<a href="https://rust-random.github.io/rand/rand/seq/trait.IteratorRandom.html"><code>IteratorRandom</code></a> and <a href="https://rust-random.github.io/rand/rand/seq/trait.SliceRandom.html"><code>SliceRandom</code></a>.</p>
<h2><a class="header" href="#fixed-seed-rngs" id="fixed-seed-rngs">Fixed seed RNGs</a></h2>
<p>You may have noticed the use of <code>thread_rng()</code> above and wondered how to
specify a fixed seed. To do so, you need to specify an RNG then use a method
like <a href="https://rust-random.github.io/rand/rand/trait.SeedableRng.html#method.seed_from_u64"><code>seed_from_u64</code></a> or <a href="https://rust-random.github.io/rand/rand/trait.SeedableRng.html#tymethod.from_seed"><code>from_seed</code></a>.</p>
<p>Note that <a href="https://rust-random.github.io/rand/rand/trait.SeedableRng.html#method.seed_from_u64"><code>seed_from_u64</code></a> is <strong>not suitable for cryptographic uses</strong> since a
single <code>u64</code> cannot provide sufficient entropy to securely seed an RNG.
All cryptographic RNGs accept a more appropriate seed via <a href="https://rust-random.github.io/rand/rand/trait.SeedableRng.html#tymethod.from_seed"><code>from_seed</code></a>.</p>
<p>We use <code>ChaCha8Rng</code> below because it is fast and portable with good quality.
See the <a href="guide-rngs.html">RNGs</a> section for more RNGs, but avoid <code>SmallRng</code> and <code>StdRng</code> if you
care about reproducible results.</p>
<pre><pre class="playground"><code class="language-rust editable">extern crate rand;
extern crate rand_chacha;

use rand::{Rng, SeedableRng};

fn main() {
    let mut rng = rand_chacha::ChaCha8Rng::seed_from_u64(10);
    println!(&quot;Random f32: {}&quot;, rng.gen::&lt;f32&gt;());
}
</code></pre></pre>
<h1><a class="header" href="#crates-and-features" id="crates-and-features">Crates and features</a></h1>
<p>The Rand library consists of a family of crates. The <a href="https://rust-random.github.io/rand/rand/index.html"><code>rand</code></a> crate provides the
main user-interface; where additional distributions are required, the
<a href="https://rust-random.github.io/rand/rand_distr/index.html"><code>rand_distr</code></a> or <a href="https://github.com/boxtown/statrs"><code>statrs</code></a> crate may be used in addition.</p>
<p>The library contains several building blocks: <a href="https://docs.rs/getrandom/"><code>getrandom</code></a> interfaces with the
platform-dependent random number source, <a href="https://rust-random.github.io/rand/rand_core/index.html"><code>rand_core</code></a> defines the API that
generators must implement, and a number of crates like <a href="https://rust-random.github.io/rand/rand_chacha/index.html"><code>rand_chacha</code></a> and
<a href="https://docs.rs/rand_xoshiro/"><code>rand_xoshiro</code></a> provide pseudo-random generators.</p>
<pre><code>getrandom ┐
          └ rand_core ┐
                      ├ rand_chacha ┐
                      ├ rand_hc     ┤
                      ├ rand_pcg    ┤
                      └─────────────┴ rand ┐
                                           ├ rand_distr
                                           └ statrs
</code></pre>
<h2><a class="header" href="#feature-flags" id="feature-flags">Feature flags</a></h2>
<p>Rand crates allow some configuration via feature flags. Check the READMEs of
individual crates for details.</p>
<p>No-std support is available across most Rand crates by disabling default
features: <code>rand = { version = &quot;0.7&quot;, default-features = false }</code>.
This is affected by the following flags:</p>
<ul>
<li><code>std</code> opts-in to functionality dependent on the <code>std</code> lib</li>
<li><code>alloc</code> (implied by <code>std</code>) enables functionality requiring an allocator
(when using this feature in <code>no_std</code>, Rand requires Rustc version 1.36 or greater)</li>
</ul>
<p>Some Rand crates can be built with support for the following third-party crates:</p>
<ul>
<li><code>log</code> enables a few log messages via <a href="https://docs.rs/log/"><code>log</code></a></li>
<li><code>serde1</code> enables serialization via <a href="https://serde.rs/"><code>serde</code></a>, version 1.0</li>
</ul>
<p>Note that cryptographic RNGs <em>do not</em> support serialisation since this could be
a security risk. If you need state-restore functionality on a cryptographic RNG,
the ChaCha generator supports <a href="https://rust-random.github.io/rand/rand_chacha/struct.ChaCha20Rng.html#method.get_word_pos">getting and setting the stream position</a>,
which, together with the seed, can be used to reconstruct the generator's state.</p>
<h2><a class="header" href="#wasm-support" id="wasm-support">WASM support</a></h2>
<p>Almost all Rand crates support WASM out of the box. Only the <code>rand_core</code> crate <a href="https://github.com/rust-random/getrandom#features">may
require enabling features for WASM support</a>.
Consequently, if you are using another crate depending on <code>rand_core</code> (such as
most Rand crates), you may have to explicitly enable <code>getrandom</code> features for it
to work.</p>
<h1><a class="header" href="#rand-and-co" id="rand-and-co">Rand and co</a></h1>
<h2><a class="header" href="#rand_core-api" id="rand_core-api">rand_core (API)</a></h2>
<p>The <a href="https://rust-random.github.io/rand/rand_core/index.html"><code>rand_core</code></a> crate defines the core traits implemented by RNGs. This exists
as a separate crate with two purposes:</p>
<ul>
<li>to provide a minimal API for defining and using RNGs</li>
<li>to provide tools to aid implementation of RNGs</li>
</ul>
<p>The <a href="https://rust-random.github.io/rand/rand_core/trait.RngCore.html"><code>RngCore</code></a>, <a href="https://rust-random.github.io/rand/rand_core/trait.SeedableRng.html"><code>SeedableRng</code></a>, <a href="https://rust-random.github.io/rand/rand_core/trait.CryptoRng.html"><code>CryptoRng</code></a> traits and <a href="https://rust-random.github.io/rand/rand_core/struct.Error.html"><code>Error</code></a> type are
all defined by this crate and re-exported by the <a href="https://rust-random.github.io/rand/rand/index.html"><code>rand</code></a> crate.</p>
<h2><a class="header" href="#rand-primary-interface" id="rand-primary-interface">rand (primary interface)</a></h2>
<p>The <a href="https://rust-random.github.io/rand/rand/index.html"><code>rand</code></a> crate is optimised for easy usage of common random-number
functionality. This has several aspects:</p>
<ul>
<li>the <a href="https://rust-random.github.io/rand/rand/rngs/index.html"><code>rngs</code></a> module provides a few convenient generators</li>
<li>the <a href="https://rust-random.github.io/rand/rand/distributions/index.html"><code>distributions</code></a> module concerns sampling of random values</li>
<li>the <a href="https://rust-random.github.io/rand/rand/seq/index.html"><code>seq</code></a> module concerns sampling from and shuffling sequences</li>
<li>the <a href="https://rust-random.github.io/rand/rand/trait.Rng.html"><code>Rng</code></a> trait provides a few convenience methods for generating
random values</li>
<li>the <a href="https://rust-random.github.io/rand/rand/fn.random.html"><code>random</code></a> function provides convenient generation in a single call</li>
</ul>
<h3><a class="header" href="#feature-flags-1" id="feature-flags-1">Feature flags</a></h3>
<p>Besides the <a href="crates.html#feature-flags">common feature flags</a>, several aspects are configurable:</p>
<ul>
<li><code>small_rng</code> enables the <a href="https://rust-random.github.io/rand/rand/rngs/struct.SmallRng.html"><code>SmallRng</code></a> generator (feature-gated since v0.7)</li>
<li><code>simd_support</code> enables experimental (nightly-only) support for generating
SIMD values</li>
</ul>
<p>Note regarding SIMD: the above flag concerns explicit generation of SIMD types
only and not optimisation. SIMD operations may be used internally regardless of
this flag; e.g. the ChaCha generator has explicit support for SIMD operations
internally.</p>
<h2><a class="header" href="#distributions" id="distributions">Distributions</a></h2>
<p>The <a href="https://rust-random.github.io/rand/rand/index.html"><code>rand</code></a> crate only implements sampling from the most common random
number distributions: uniform and weighted sampling. For everything else,</p>
<ul>
<li><a href="https://rust-random.github.io/rand/rand_distr/index.html"><code>rand_distr</code></a> provides fast sampling from a variety of other distributions,
including Normal (Gauss), Binomial, Poisson, UnitCircle, and many more</li>
<li><a href="https://github.com/boxtown/statrs"><code>statrs</code></a> is a port of the C# Math.NET library, implementing many of the
same distributions (plus/minus a few), along with PDF and CDF functions,
the <em>error</em>, <em>beta</em>, <em>gamma</em> and <em>logistic</em> special functions, plus a few
utilities. (For clarity, <a href="https://github.com/boxtown/statrs"><code>statrs</code></a> is not part of the Rand library.)</li>
</ul>
<h1><a class="header" href="#random-generators" id="random-generators">Random Generators</a></h1>
<h2><a class="header" href="#getrandom" id="getrandom">Getrandom</a></h2>
<p>The <a href="https://docs.rs/getrandom/"><code>getrandom</code></a> crate provides a low-level API around platform-specific
random-number sources, and is an important building block of <code>rand</code> and
<code>rand_core</code> as well as a number of cryptography libraries.
It is not intended for usage outside of low-level libraries.</p>
<p>In some cases, particularly when targetting WASM, end-users may need to
configure this crate.
Consult the <a href="https://docs.rs/getrandom/"><code>getrandom</code></a> documentation for the relevant version.</p>
<h2><a class="header" href="#cpu-jitter" id="cpu-jitter">CPU Jitter</a></h2>
<p>The <a href="https://docs.rs/rand_jitter/"><code>rand_jitter</code></a> crate implements a CPU-jitter-based entropy harvestor which
may be used to provide an alternative source of entropy where a high-resolution
CPU timer is available.</p>
<p>It should be noted that CPU-jitter harvestors <a href="https://github.com/rust-random/rand/issues/699">may be prone to side-channel
attacks</a> and that this
implementation is quite slow (due to conservative estimates of entropy gained
per step).</p>
<p>In prior versions of <code>rand</code> this was a direct dependency, used
automatically when other sources of entropy failed.
In current versions it is not a dependency (not even an optional one).</p>
<h2><a class="header" href="#deterministic-generators" id="deterministic-generators">Deterministic generators</a></h2>
<p>The following crates implement pseudo-random number generators
(see <a href="guide-rngs.html">Our RNGs</a>):</p>
<ul>
<li><a href="https://rust-random.github.io/rand/rand_chacha/index.html"><code>rand_chacha</code></a> provides generators using the ChaCha cipher</li>
<li><a href="https://rust-random.github.io/rand/rand_hc/index.html"><code>rand_hc</code></a> implements a generator using the HC-128 cipher</li>
<li><a href="https://docs.rs/rand_isaac/"><code>rand_isaac</code></a> implements the ISAAC generators</li>
<li><a href="https://rust-random.github.io/rand/rand_pcg/index.html"><code>rand_pcg</code></a> implements a small selection of PCG generators</li>
<li><a href="https://docs.rs/rand_xoshiro/"><code>rand_xoshiro</code></a> implements the SplitMix and Xoshiro generators</li>
<li><a href="https://docs.rs/rand_xorshift/"><code>rand_xorshift</code></a> implements the basic Xorshift generator</li>
</ul>
<h1><a class="header" href="#guide" id="guide">Guide</a></h1>
<p>This section attempts to explain some of the concepts used in this library.</p>
<ol>
<li><a href="guide-data.html">What is random data and what is randomness anyway?</a></li>
<li><a href="guide-gen.html">What kind of random generators are there?</a></li>
<li><a href="guide-rngs.html">What random number generators does Rand provide?</a></li>
<li><a href="guide-values.html">Turning random data into useful values</a></li>
<li><a href="guide-dist.html">Distributions: more control over random values</a></li>
<li><a href="guide-seq.html">Sequences</a></li>
<li><a href="guide-err.html">Error handling</a></li>
</ol>
<h2><a class="header" href="#importing-items-prelude" id="importing-items-prelude">Importing items (prelude)</a></h2>
<p>The most convenient way to import items from Rand is to use the <a href="../rand/rand/prelude/index.html"><code>prelude</code></a>.
This includes the most important parts of Rand, but only those unlikely to
cause name conflicts.</p>
<p>Note that Rand 0.5 has significantly changed the module organization and
contents relative to previous versions. Where possible old names have been
kept (but are hidden in the documentation), however these will be removed
in the future. We therefore recommend migrating to use the prelude or the
new module organization in your imports.</p>
<h2><a class="header" href="#further-examples" id="further-examples">Further examples</a></h2>
<p>For some inspiration, see the example applications:</p>
<ul>
<li><a href="https://github.com/rust-random/rand/blob/master/examples/monte-carlo.rs">Monte Carlo estimation of π</a></li>
<li><a href="https://github.com/rust-random/rand/blob/master/examples/monty-hall.rs">Monty Hall Problem</a></li>
</ul>
<h1><a class="header" href="#random-data" id="random-data">Random data</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rand;
</span><span class="boring">use rand::RngCore;
</span>// get some random data:
let mut data = [0u8; 32];
rand::thread_rng().fill_bytes(&amp;mut data);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#what-is-randomness" id="what-is-randomness">What is randomness?</a></h2>
<p>What does <strong>random</strong> mean? Colloquially the word can mean simply <em>unexpected</em>
or <em>unknown</em>, but we need to be a bit more precise than that. Wikipedia gives us
a more specific definition:</p>
<blockquote>
<p><strong>Randomness</strong> is the lack of pattern or predictability in events.</p>
</blockquote>
<p>We can take this further: <em>lack of pattern</em> implies there is no <em>bias</em>; in
other words, all possible values are equally likely.</p>
<p>To understand what a <em>random value</em> is, we still need a context: what pool of
numbers can our random value come from?</p>
<ul>
<li>To give a simple example, consider dice: they have values 1, 2, 3, 4, 5 and
6, and an unbiased (fair) die will make each number equally likely, with
probability ⅙th.</li>
<li>Now lets take a silly example: the natural numbers (1, 2, 3, etc.). These
numbers have no limit. So if you were to ask for an unbiased random
natural number, 1, 5, 1000, 1 million, 1 trillion — all would be equally
likely. In fact, for <em>any</em> natural number <code>k</code>, the numbers <code>1, 2, ..., k</code>
are an infinitely small fraction of all the natural numbers, which means the
chance of picking a unbiased number from this range is effectively <code>1/∞ = 0</code>.
Put another way: for <em>any</em> natural number, we expect an unbiased random
value to be bigger. This is impossible, so there cannot be any such thing as
an unbiased random natural number.</li>
<li>Another example: real numbers between 0 and 1. Real numbers include all the
fractions, irrational numbers like π and √2, and all multiples of those...
there are infinitely many possibilities, even in a small range like <code>(0, 1)</code>,
so simply saying &quot;all possibilities are equally likely&quot; is not enough.
Instead we interpret <em>lack of pattern</em> in a different way: every interval
of equal size is equally likely; for example we could subdivide the interval
<code>0,1</code> into <code>0,½</code> and <code>½,1</code> and toss a coin to decide which interval our
random sample comes from. Say we pick <code>½,1</code> we can then toss another coin to
decide between <code>½,¾</code> and <code>¾,1</code>, restricting our random value to an interval
of size <code>¼</code>. We can repeat this as many times as necessary to pick a random
value between <code>0</code> and <code>1</code> with as much precision as we want — although we
should realise that we are not choosing an <em>exact</em> value but rather just a
small interval.</li>
</ul>
<p>What we have defined (or failed to define) above are uniform random number
distributions, or simply <strong>uniform distributions</strong>. There are also non-uniform
distributions, as we shall see later. It's also worth noting here that a
uniform distribution does not imply that its samples will be <em>evenly</em> spread
(try rolling six dice: you probably won't get 1, 2, 3, 4, 5, 6).</p>
<p>To bring us back to computing, we can now define what a uniformly distributed
random value (an unbiased random value) is in several contexts:</p>
<ul>
<li><code>u32</code>: a random number between 0 and <code>u32::MAX</code> where each value is equally
likely</li>
<li><code>BigInt</code>: since this type has no upper bound, we cannot produce an unbiased
random value (it would be infinitely large, and use infinite amounts of memory)</li>
<li><code>f64</code>: we treat this as an approximation of the real numbers, and,
<em>by convention</em>, restrict to the range 0 to 1 (if not otherwise specified).
We will come back to the conversions used later;
for now note that these produce 52-53 bits of precision (depending on which
conversion is used, output will be in steps of <code>ε</code> or <code>ε/2</code>, where <code>1+ε</code> is
the smallest representable value greater than <code>1</code>).</li>
</ul>
<h2><a class="header" href="#random-data-1" id="random-data-1">Random data</a></h2>
<p>As seen above, the term &quot;random number&quot; is meaningless without context. &quot;Random
data&quot; typically means a sequence of random <em>bytes</em>, where for each byte, each of
the 256 possible values are equally likely.</p>
<p><a href="../rand/rand_core/trait.RngCore.html#tymethod.fill_bytes"><code>RngCore::fill_bytes</code></a> produces exactly this: a sequence of random bytes.</p>
<p>If a sequence of unbiased random bytes of the correct length is instead
interpreted as an integer — say a <code>u32</code> or <code>u64</code> — the result is an unbiased
integer. Since this conversion is trivial, <a href="../rand/rand_core/trait.RngCore.html#tymethod.next_u32"><code>RngCore::next_u32</code></a> and
<a href="../rand/rand_core/trait.RngCore.html#tymethod.next_u64"><code>RngCore::next_u64</code></a> are part of the same trait. (In fact the conversion is
often the other way around — algorithmic generators usually work with integers
internally, which are then converted to whichever form of random data is
required.)</p>
<h1><a class="header" href="#types-of-generators" id="types-of-generators">Types of generators</a></h1>
<p>The previous section introduced <a href="../rand/rand_core/trait.RngCore.html"><code>RngCore</code></a>, the trait which all <em>random data
sources</em> must implement. But what exactly is a random data source?</p>
<p>This section concerns theory; see also the chapter on
<a href="guide-rngs.html">random number generators</a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rand;
</span><span class="boring">extern crate rand_pcg;
</span>// prepare a non-deterministic random number generator:
let mut rng = rand::thread_rng();

// prepare a deterministic generator:
use rand::SeedableRng;
let mut rng = rand_pcg::Pcg32::seed_from_u64(123);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#true-random-number-generators" id="true-random-number-generators">True random number generators</a></h2>
<p>A <strong>true</strong> random number generator (TRNG) is something which produces random
numbers by observing some natural process, such as atomic decay or thermal noise.
(Whether or not these things are <em>truly</em> random or are in fact deterministic —
for example if the universe itself is a simulation — is besides the point here.
For our purposes, it is sufficient that they are not distinguishable from true
randomness.)</p>
<p>Note that these processes are often biased, thus some type of <em>debiasing</em> must
be used to yield the unbiased random data we desire.</p>
<h2><a class="header" href="#pseudo-random-number-generators" id="pseudo-random-number-generators">Pseudo-random number generators</a></h2>
<p>CPUs are of course supposed to compute deterministically, yet it turns out they
can do a pretty good job of emulating random processes. Most pseudo-random
number generators are deterministic and can be defined by just:</p>
<ul>
<li>some initial <em>state</em></li>
<li>a function to compute a random value from the state</li>
<li>a function to advance to the next state</li>
<li>(optionally) a function to derive the initial state from a <em>seed</em> or <em>key</em></li>
</ul>
<p>The fact that these are deterministic can sometimes be very useful: it allows a
simulation, randomised art work or game to be repeated exactly, producing a
result which is a function of the seed. For more on this see the
<a href="portability.html">portability</a> chapter (note that determinicity alone isn't
enough to guarantee reproducibility).</p>
<p>The other big attraction of PRNGs is their speed: some of these algorithms
require only a few CPU operations per random value, and thus can produce
random data on demand much more quickly than most TRNGs.</p>
<p>Note however that PRNGs have several limitations:</p>
<ul>
<li>They are no stronger than their seed: if the seed is known or guessable,
and the algorithm is known (or guessed), then only a small number of output
sequences are likely.</li>
<li>Since the state size is usually fixed, only a finite number of output values
are possible before the generator loops and repeats itself.</li>
<li>Several algorithms are easily predictable after seeing a few values, and
with many other algorithms it is not clear whether they could be &quot;cracked&quot;.</li>
</ul>
<h2><a class="header" href="#cryptographically-secure-pseudo-random-number-generator" id="cryptographically-secure-pseudo-random-number-generator">Cryptographically secure pseudo-random number generator</a></h2>
<p>Cryptographically secure pseudo-random number generators (CSPRNGs) are the
subset of PRNGs which are considered secure. That is:</p>
<ul>
<li>their state is sufficiently large that a brute-force approach simply trying
all initial values is not a feasible method of finding the initial state
used to produce an observed sequence of output values,</li>
<li>and there is no other algorithm which is sufficiently better than the
brute-force method which would make it feasible to predict the next output
value.</li>
</ul>
<p>Achieving secure generation requires not only a secure algorithm (CSPRNG), but
also a secure and sufficiently large seed value (typically 256 bits), and
protection against side-channel attacks (i.e. preventing attackers from reading
the internal state).</p>
<p>Some CSPRNGs additionally satisfy a third property:</p>
<ul>
<li>a CSPRNG is backtracking resistant if it is impossible for an attacker to
calculate prior output values of the PRNG despite having discovered the
value of the current internal state (implying that all future output is
compromised).</li>
</ul>
<h2><a class="header" href="#hardware-random-number-generator" id="hardware-random-number-generator">Hardware random number generator</a></h2>
<p>A <strong>hardware</strong> random number generator (HRNG) is theoretically an adaptor from
some TRNG to digital information. In practice, these may use a PRNG to debias
the TRNG. Even though an HRNG has some underlying TRNG, it is not guaranteed to
be secure: the TRNG itself may produce insufficient entropy (i.e. be too
predictable), or the signal amplification and debiasing process may be flawed.</p>
<p>An HRNG may be used to provide the seed for a PRNG, although usually this is not
the only way to obtain a secure seed (see the next section). An HRNG might
replace a PRNG altogether, although since we now have very fast and very strong
software PRNGs, and since software implementations are easier to verify than
hardware ones, this is often not the preferred solution.</p>
<p>Since a PRNG needs a random seed value to be secure, an HRNG may be used to
provide that seed, or even replace the need for a PRNG. However, since the goal
is usually &quot;only&quot; to produce unpredictable random values, there are acceptable
alternatives to <em>true</em> random number generators (see next section).</p>
<h2><a class="header" href="#entropy" id="entropy">Entropy</a></h2>
<p>As noted above, for a CSPRNG to be secure, its seed value must also be secure.
The word <em>entropy</em> can be used in two ways:</p>
<ul>
<li>as a measure of the amount of unknown information in some piece of data</li>
<li>as a piece of unknown data</li>
</ul>
<p>Ideally, a random boolean or a coin flip has 1 bit of entropy, although if the
value is biased, there will be less. Shannon Entropy attempts to measure this.</p>
<p>For example, a Unix time-stamp (seconds since the start of 1970) contains both
high- and low-resolution data. This is typically a 32-bit number, but the amount
of <em>entropy</em> will depend on how precisely a hypothetical attacker can guess the
number. If an attacker can guess the number to the nearest minute, this may be
approximately 6 bits (2^6 = 64); if an attacker can guess this to the second,
this is 0 bits. <a href="../rand/rand/rngs/jitter/struct.JitterRng.html"><code>JitterRng</code></a> uses this concept to scavenge entropy without an
HRNG (but using nanosecond resolution timers and conservatively assuming only a
couple of bits entropy is available per time-stamp, after running several tests
on the timer's quality).</p>
<h1><a class="header" href="#our-rngs" id="our-rngs">Our RNGs</a></h1>
<p>There are many kinds of RNGs, with different trade-offs. Rand provides some
convenient generators in the <a href="../rand/rand/rngs/index.html"><code>rngs</code> module</a>. Often you can just use
<a href="../rand/rand/fn.thread_rng.html"><code>thread_rng</code></a>, a function which automatically initializes an RNG in
thread-local memory and returns a reference to it. It is fast, good quality,
and (to the best of our knowledge) cryptographically secure.</p>
<p>Contents of this documentation:</p>
<ol>
<li><a href="guide-rngs.html#the-generators">The generators</a></li>
<li><a href="guide-rngs.html#performance">Performance and size</a></li>
<li><a href="guide-rngs.html#quality">Quality and cycle length</a></li>
<li><a href="guide-rngs.html#security">Security</a></li>
<li><a href="guide-rngs.html#extra-features">Extra features</a></li>
<li><a href="guide-rngs.html#further-reading">Further reading</a></li>
</ol>
<h1><a class="header" href="#the-generators" id="the-generators">The generators</a></h1>
<h2><a class="header" href="#basic-pseudo-random-number-generators-prngs" id="basic-pseudo-random-number-generators-prngs">Basic pseudo-random number generators (PRNGs)</a></h2>
<p>The goal of &quot;standard&quot; non-cryptographic PRNGs is usually to find a good
balance between simplicity, quality, memory usage and performance.
Non-cryptographic generators pre-date cryptographic ones and are in some ways
obsoleted by them, however some advantages may be on available:
a small state size, fast initialisation, simplicity, lower energy usage for
embedded CPUs. (However, not all non-crypto PRNGs provide these benefits,
e.g. the Mersenne Twister has a very large state despite being easy to predict).</p>
<p>These algorithms are very important to Monte Carlo simulations, and also
suitable for several other problems such as randomized algorithms and games,
where predictability is not an issue. (Note however that for gambling games
predictability may be an issue and a cryptographic PRNG is recommended.)</p>
<p>The Rand project provides several non-cryptographic PRNGs. A sub-set of these
are summarised below.
You may wish to refer to the <a href="http://www.pcg-random.org/">pcg-random</a> and <a href="http://xoshiro.di.unimi.it/">xoshiro</a> websites.</p>
<table><thead><tr><th>name</th><th>full name</th><th>performance</th><th>memory</th><th>quality</th><th>period</th><th>features</th></tr></thead><tbody>
<tr><td><a href="../rand/rand/rngs/struct.SmallRng.html"><code>SmallRng</code></a></td><td>(unspecified)</td><td>7 GB/s</td><td>16 bytes</td><td>★★★☆☆</td><td>≥ <code>u32</code> * 2<sup>64</sup></td><td>not portable</td></tr>
<tr><td><a href="../rand/rand_pcg/type.Pcg32.html"><code>Pcg32</code></a></td><td>PCG XSH RR 64/32 (LCG)</td><td>3 GB/s</td><td>16 bytes</td><td>★★★☆☆</td><td><code>u32</code> * 2<sup>64</sup></td><td>—</td></tr>
<tr><td><a href="../rand/rand_pcg/type.Pcg64.html"><code>Pcg64</code></a></td><td>PCG XSL 128/64 (LCG)</td><td>4 GB/s</td><td>32 bytes</td><td>★★★☆☆</td><td><code>u64</code> * 2<sup>128</sup></td><td>—</td></tr>
<tr><td><a href="../rand/rand_pcg/type.Pcg64Mcg.html"><code>Pcg64Mcg</code></a></td><td>PCG XSL 128/64 (MCG)</td><td>7 GB/s</td><td>16 bytes</td><td>★★★☆☆</td><td><code>u64</code> * 2<sup>126</sup></td><td>—</td></tr>
<tr><td><a href="https://docs.rs/rand_xorshift/latest/rand_xorshift/struct.XorShiftRng.html"><code>XorShiftRng</code></a></td><td>Xorshift 32/128</td><td>5 GB/s</td><td>16 bytes</td><td>★☆☆☆☆</td><td><code>u32</code> * 2<sup>128</sup> - 1</td><td>—</td></tr>
<tr><td><a href="https://docs.rs/rand_xoshiro/latest/rand_xoshiro/struct.Xoshiro256PlusPlus.html"><code>Xoshiro256PlusPlus</code></a></td><td>Xoshiro256++</td><td>7 GB/s</td><td>32 bytes</td><td>★★★☆☆</td><td><code>u64</code> * 2<sup>256</sup> - 1</td><td>jump-ahead</td></tr>
<tr><td><a href="https://docs.rs/rand_xoshiro/latest/rand_xoshiro/struct.Xoshiro256Plus.html"><code>Xoshiro256Plus</code></a></td><td>Xoshiro256+</td><td>8 GB/s</td><td>32 bytes</td><td>★★☆☆☆</td><td><code>u64</code> * 2<sup>256</sup> - 1</td><td>jump-ahead</td></tr>
<tr><td><a href="https://docs.rs/rand_xoshiro/latest/rand_xoshiro/struct.SplitMix64.html"><code>SplitMix64</code></a></td><td>splitmix64</td><td>8 GB/s</td><td>8 bytes</td><td>★☆☆☆☆</td><td><code>u64</code> * 2<sup>64</sup></td><td>—</td></tr>
<tr><td><a href="../rand/rand/rngs/mock/struct.StepRng.html"><code>StepRng</code></a></td><td>counter</td><td>51 GB/s</td><td>16 bytes</td><td>☆☆☆☆☆</td><td><code>u64</code> * 2<sup>64</sup></td><td>—</td></tr>
</tbody></table>
<p>Here, performance is measured roughly for <code>u64</code> outputs on a 3.4GHz Haswell CPU
(note that this will vary significantly by application; in general cryptographic
RNGs do better with byte sequence output). Quality ratings are
based on theory and observable defects, roughly as follows:</p>
<ul>
<li>★☆☆☆☆ = suitable for simple applications but with significant flaws</li>
<li>★★☆☆☆ = good performance in most tests, some issues</li>
<li>★★★☆☆ = good performance and theory, no major issues</li>
<li>★★★★★ = cryptographic quality</li>
</ul>
<h2><a class="header" href="#cryptographically-secure-pseudo-random-number-generators-csprngs" id="cryptographically-secure-pseudo-random-number-generators-csprngs">Cryptographically secure pseudo-random number generators (CSPRNGs)</a></h2>
<p>CSPRNGs have much higher requirements than basic PRNGs. The primary
consideration is security. Performance and simplicity are also important,
but in general CSPRNGs are more complex and slower than regular PRNGs.
Quality is no longer a concern, as it is a requirement for a
CSPRNG that the output is basically indistinguishable from true randomness
since any bias or correlation makes the output more predictable.</p>
<p>There is a close relationship between CSPRNGs and cryptographic ciphers.
Any block cipher can be turned into a CSPRNG by encrypting a counter. Stream
ciphers are basically a CSPRNG and a combining operation, usually XOR. This
means that we can easily use any stream cipher as a CSPRNG.</p>
<p>This library provides the following CSPRNGs. We can make no guarantees
of any security claims. This table omits the &quot;quality&quot; column from the previous
table since CSPRNGs may not have observable defects.</p>
<table><thead><tr><th>name</th><th>full name</th><th>performance</th><th>initialization</th><th>memory</th><th>security (predictability)</th><th>forward secrecy</th></tr></thead><tbody>
<tr><td><a href="../rand/rand/rngs/struct.StdRng.html"><code>StdRng</code></a></td><td>(unspecified)</td><td>1.5 GB/s</td><td>fast</td><td>136 bytes</td><td>widely trusted</td><td>no</td></tr>
<tr><td><a href="../rand/rand_chacha/struct.ChaCha20Rng.html"><code>ChaCha20Rng</code></a></td><td>ChaCha20</td><td>1.8 GB/s</td><td>fast</td><td>136 bytes</td><td><a href="https://tools.ietf.org/html/rfc7539#section-1">rigorously analysed</a></td><td>no</td></tr>
<tr><td><a href="../rand/rand_chacha/struct.ChaCha8Rng.html"><code>ChaCha8Rng</code></a></td><td>ChaCha8</td><td>2.2 GB/s</td><td>fast</td><td>136 bytes</td><td>small security margin</td><td>no</td></tr>
<tr><td><a href="../rand/rand_hc/struct.Hc128Rng.html"><code>Hc128Rng</code></a></td><td>HC-128</td><td>2.1 GB/s</td><td>slow</td><td>4176 bytes</td><td><a href="http://www.ecrypt.eu.org/stream/">recommended by eSTREAM</a></td><td>no</td></tr>
<tr><td><a href="https://docs.rs/rand_isaac/latest/rand_isaac/isaac/struct.IsaacRng.html"><code>IsaacRng</code></a></td><td>ISAAC</td><td>1.1 GB/s</td><td>slow</td><td>2072 bytes</td><td><a href="https://burtleburtle.net/bob/rand/isaacafa.html">unknown</a></td><td>unknown</td></tr>
<tr><td><a href="https://docs.rs/rand_isaac/latest/rand_isaac/isaac64/struct.Isaac64Rng.html"><code>Isaac64Rng</code></a></td><td>ISAAC-64</td><td>2.2 GB/s</td><td>slow</td><td>4136 bytes</td><td>unknown</td><td>unknown</td></tr>
</tbody></table>
<p>It should be noted that the ISAAC generators are only included for
historical reasons, they have been with the Rust language since the very
beginning. They have good quality output and no attacks are known, but have
received little attention from cryptography experts.</p>
<h1><a class="header" href="#notes-on-generators" id="notes-on-generators">Notes on generators</a></h1>
<h2><a class="header" href="#performance" id="performance">Performance</a></h2>
<p>First it has to be said most PRNGs are very fast, and will rarely be a
performance bottleneck.</p>
<p>Performance of basic PRNGs is a bit of a subtle thing. It depends a lot on
the CPU architecture (32 vs. 64 bits), inlining, and also on the number of
available registers. This often causes the performance to be affected by
surrounding code due to inlining and other usage of registers.</p>
<p>When choosing a PRNG for performance it is important to benchmark your own
application due to interactions between PRNGs and surrounding code and
dependence on the CPU architecture as well as the impact of the size of
data requested. Because of all this, we do not include performance numbers
here but merely a qualitative rating.</p>
<p>CSPRNGs are a little different in that they typically generate a block of
output in a cache, and pull outputs from the cache. This allows them to have
good amortised performance, and reduces or completely removes the influence
of surrounding code on the CSPRNG performance.</p>
<h3><a class="header" href="#worst-case-performance" id="worst-case-performance">Worst-case performance</a></h3>
<p>Simple PRNGs typically produce each random value on demand. In contrast, CSPRNGs
usually produce a whole block at once, then read from this cache until it is
exhausted, giving them much less consistent performance when drawing small
quantities of random data.</p>
<h3><a class="header" href="#memory-usage" id="memory-usage">Memory usage</a></h3>
<p>Simple PRNGs often use very little memory, commonly only a few words, where
a <em>word</em> is usually either <code>u32</code> or <code>u64</code>. This is not true for all
non-cryptographic PRNGs however, for example the historically popular
Mersenne Twister MT19937 algorithm requires 2.5 kB of state.</p>
<p>CSPRNGs typically require more memory; since the seed size is recommended
to be at least 192 bits and some more may be required for the algorithm,
256 bits would be approximately the minimum secure size. In practice,
CSPRNGs tend to use quite a bit more, <a href="../rand/rand_chacha/struct.ChaChaRng.html"><code>ChaChaRng</code></a> is relatively small with
136 bytes of state.</p>
<h3><a class="header" href="#initialization-time" id="initialization-time">Initialization time</a></h3>
<p>The time required to initialize new generators varies significantly. Many
simple PRNGs and even some cryptographic ones (including <a href="../rand/rand_chacha/struct.ChaChaRng.html"><code>ChaChaRng</code></a>)
only need to copy the seed value and some constants into their state, and
thus can be constructed very quickly. In contrast, CSPRNGs with large state
require an expensive key-expansion.</p>
<h2><a class="header" href="#quality" id="quality">Quality</a></h2>
<p>Many basic PRNGs are not much more than a couple of bitwise and arithmetic
operations. Their simplicity gives good performance, but also means there
are small regularities hidden in the generated random number stream.</p>
<p>How much do those hidden regularities matter? That is hard to say, and
depends on how the RNG gets used. If there happen to be correlations between
the random numbers and the algorithm they are used in, the results can be
wrong or misleading.</p>
<p>A random number generator can be considered good if it gives the correct
results in as many applications as possible. The quality of PRNG
algorithms can be evaluated to some extend analytically, to determine the
cycle length and to rule out some correlations. Then there are empirical
test suites designed to test how well a PRNG performs on a wide range of
possible uses, the latest and most complete of which are <a href="http://simul.iro.umontreal.ca/testu01/tu01.html">TestU01</a> and
<a href="http://pracrand.sourceforge.net/">PractRand</a>.</p>
<p>CSPRNGs tend to be more complex, and have an explicit requirement to be
unpredictable. This implies there must be no obvious correlations between
output values.</p>
<h3><a class="header" href="#quality-stars" id="quality-stars">Quality stars:</a></h3>
<p>PRNGs with 3 stars or more should be good enough for most non-crypto
applications. 1 or 2 stars may be good enough for typical apps and games, but do
not work well with all algorithms.</p>
<h3><a class="header" href="#period" id="period">Period</a></h3>
<p>The <em>period</em> or <em>cycle length</em> of a PRNG is the number of values that can be
generated after which it starts repeating the same random number stream.
Many PRNGs have a fixed-size period, while for others (&quot;chaotic RNGs&quot;) the
cycle length may depend on the seed and short cycles may exist.</p>
<p>Note that a long period does not imply high quality (e.g. a counter through
<code>u128</code> values provides a decently long period). Conversely, a short period may
be a problem, especially when multiple RNGs are used simultaneously.
In general, we recommend a period of at least 2<sup>128</sup>.
(Alternatively, a PRNG with shorter period of at least 2<sup>64</sup> and
support for multiple streams may be sufficient. Note however that in the case
of PCG, its streams are closely correlated.)</p>
<p><em>Avoid reusing values!</em>
On today's hardware, a fast RNG with a cycle length of <em>only</em>
2<sup>64</sup> can be used sequentially for centuries before cycling. However,
when multiple RNGs are used in parallel (each with a unique seed), there is a
significant chance of overlap between the sequences generated.
For a generator with a <em>large</em> period <code>P</code>, <code>n</code> independent generators, and
a sequence of length <code>L</code> generated by each generator, the chance of any overlap
between sequences can be approximated by <code>Ln² / P</code> when <code>nL / P</code> is close to
zero. For more on this topic, please see these
<a href="http://prng.di.unimi.it/#remarks">remarks by the Xoshiro authors</a>.</p>
<p><em>Collisions and the birthday paradox!</em>
For a generator with outputs of equal size to its state, it is recommended not
to use more than <code>√P</code> outputs. A generalisation for <code>kw</code>-bit state and <code>w</code>-bit
generators is to ensure <code>kL² &lt; P</code>. This requirement stems from the
<em>generalised birthday problem</em>, asking how many unbiased samples from a set of
size <code>d = 2^w</code> can be taken before the probability of a repeat is at least half.
Note that for <code>kL² &gt; P</code> a generator with <code>kw</code>-dimensional equidistribution
<em>cannot</em> generate the expected number of repeated samples, however generators
without this property are <em>also</em> not guaranteed to generate the expected number
of repeats.</p>
<h2><a class="header" href="#security" id="security">Security</a></h2>
<h3><a class="header" href="#predictability" id="predictability">Predictability</a></h3>
<p>From the context of any PRNG, one can ask the question <em>given some previous
output from the PRNG, is it possible to predict the next output value?</em>
This is an important property in any situation where there might be an
adversary.</p>
<p>Regular PRNGs tend to be predictable, although with varying difficulty. In
some cases prediction is trivial, for example plain Xorshift outputs part of
its state without mutation, and prediction is as simple as seeding a new
Xorshift generator from four <code>u32</code> outputs. Other generators, like
<a href="http://www.pcg-random.org/predictability.html">PCG</a> and truncated Xorshift*
are harder to predict, but not outside the realm of common mathematics and a
desktop PC.</p>
<p>The basic security that CSPRNGs must provide is the infeasibility to predict
output. This requirement is formalized as the <a href="https://en.wikipedia.org/wiki/Next-bit_test">next-bit test</a>; this is
roughly stated as: given the first <em>k</em> bits of a random sequence, the
sequence satisfies the next-bit test if there is no algorithm able to
predict the next bit using reasonable computing power.</p>
<p>A further security that <em>some</em> CSPRNGs provide is forward secrecy:
in the event that the CSPRNGs state is revealed at some point, it must be
infeasible to reconstruct previous states or output. Note that many CSPRNGs
<em>do not</em> have forward secrecy in their usual formulations.</p>
<p>Verifying security claims of an algorithm is a <em>hard problem</em>, and we are not
able to provide any guarantees of the security of algorithms used or recommended
by this project. We refer you to the <a href="https://www.nist.gov/">NIST</a> institute and <a href="http://www.ecrypt.eu.org/">ECRYPT</a> network
for recommendations.</p>
<h3><a class="header" href="#state-and-seeding" id="state-and-seeding">State and seeding</a></h3>
<p>It is worth noting that a CSPRNG's security relies absolutely on being
seeded with a secure random key. Should the key be known or guessable, all
output of the CSPRNG is easy to guess. This implies that the seed should
come from a trusted source; usually either the OS or another CSPRNG. Our
seeding helper trait, <a href="../rand/rand/trait.FromEntropy.html"><code>FromEntropy</code></a>, and the source it uses
(<a href="../rand/rand/rngs/struct.EntropyRng.html"><code>EntropyRng</code></a>), should be secure. Additionally, <a href="../rand/rand/rngs/struct.ThreadRng.html"><code>ThreadRng</code></a> is a CSPRNG,
thus it is acceptable to seed from this (although for security applications
fresh/external entropy should be preferred).</p>
<p>Further, it should be obvious that the internal state of a CSPRNG must be
kept secret. With that in mind, our implementations do not provide direct
access to most of their internal state, and <code>Debug</code> implementations do not
print any internal state. This does not fully protect CSPRNG state; code
within the same process may read this memory (and we allow cloning and
serialisation of CSPRNGs for convenience). Further, a running process may be
forked by the operating system, which may leave both processes with a copy
of the same generator.</p>
<h3><a class="header" href="#not-a-crypto-library" id="not-a-crypto-library">Not a crypto library</a></h3>
<p>It should be emphasised that this is not a cryptography library; although
Rand does take some measures to provide secure random numbers, it does not
necessarily take all recommended measures. Further, cryptographic processes
such as encryption and authentication are complex and must be implemented
very carefully to avoid flaws and resist known attacks. It is therefore
recommended to use specialized libraries where possible, for example
<a href="https://crates.io/crates/openssl">openssl</a>, <a href="https://crates.io/crates/ring">ring</a> and the <a href="https://github.com/RustCrypto">RustCrypto libraries</a>.</p>
<h2><a class="header" href="#extra-features" id="extra-features">Extra features</a></h2>
<p>Some PRNGs may provide extra features, like:</p>
<ul>
<li>Support for multiple streams, which can help with parallel tasks.</li>
<li>The ability to jump or seek around in the random number stream;
with a large period this can be used as an alternative to streams.</li>
</ul>
<h2><a class="header" href="#further-reading" id="further-reading">Further reading</a></h2>
<p>There is quite a lot that can be said about PRNGs. The <a href="http://www.pcg-random.org/pdf/hmc-cs-2014-0905.pdf">PCG paper</a> is very
approachable and explains more concepts.</p>
<p>Another good paper about RNG quality is
<a href="https://web.archive.org/web/20160801142711/http://random.mat.sbg.ac.at/results/peter/A19final.pdf">&quot;Good random number generators are (not so) easy to find&quot;</a>
by P. Hellekalek.</p>
<h1><a class="header" href="#seeding-rngs" id="seeding-rngs">Seeding RNGs</a></h1>
<p>As we have seen, the output of pseudo-random number generators (PRNGs) is
determined by their initial state.</p>
<p>Some PRNG definitions specify how the initial state should be generated from a
key, usually specified as a byte-sequence for cryptographic generators or,
for small PRNGs, often just a word. We formalise this for all our generators
with the <a href="../rand/rand_core/trait.SeedableRng.html"><code>SeedableRng</code></a> trait.</p>
<h2><a class="header" href="#the-seed-type" id="the-seed-type">The Seed type</a></h2>
<p>We require all seedable RNGs to define a <a href="../rand/rand_core/trait.SeedableRng.html#type.Seed"><code>Seed</code></a> type satisfying
<code>AsMut&lt;[u8]&gt; + Default + Sized</code> (usually <code>[u8; N]</code> for a fixed <code>N</code>).
We recommend using <code>[u8; 12]</code> or larger for non-cryptographic PRNGs and
<code>[u8; 32]</code> for cryptographic PRNGs.</p>
<p>PRNGs may be seeded directly from such a value with <a href="../rand/rand_core/trait.SeedableRng.html#tymethod.from_seed"><code>SeedableRng::from_seed</code></a>.</p>
<h2><a class="header" href="#seeding-from-" id="seeding-from-">Seeding from ...</a></h2>
<h3><a class="header" href="#fresh-entropy" id="fresh-entropy">Fresh entropy</a></h3>
<p>Using a fresh seed (direct from the OS) is easy using <a href="../rand/rand_core/trait.SeedableRng.html#method.from_entropy"><code>SeedableRng::from_entropy</code></a>:</p>
<pre><pre class="playground"><code class="language-rust editable">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rand::prelude::*;
use rand_chacha::ChaCha20Rng;

let rng = ChaCha20Rng::from_entropy();
<span class="boring">}
</span></code></pre></pre>
<p>Note that this requires <code>rand_core</code> has the feature <code>getrandom</code> enabled.</p>
<h3><a class="header" href="#another-rng" id="another-rng">Another RNG</a></h3>
<p>Quite obviously, another RNG may be used to fill a seed. We provide a
convenience method for this:</p>
<pre><pre class="playground"><code class="language-rust editable">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rand::prelude::*;
use rand_pcg::Pcg64;

let rng = Pcg64::from_rng(thread_rng());
<span class="boring">}
</span></code></pre></pre>
<p>But, say you want to save a key and use it later. For that you need to be a
little bit more explicit:</p>
<pre><pre class="playground"><code class="language-rust editable">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rand::prelude::*;
use rand_chacha::ChaCha8Rng;

let mut seed: &lt;ChaCha8Rng as SeedableRng&gt;::Seed = Default::default();
thread_rng().fill(&amp;mut seed);
let rng = ChaCha8Rng::from_seed(seed);
<span class="boring">}
</span></code></pre></pre>
<p><strong>Obligatory warning</strong>: a few simple PRNGs, notably <a href="../rand/rand_xorshift/struct.XorShiftRng.html"><code>XorShiftRng</code></a>,
behave badly when seeded from the same type of generator (in this case, Xorshift
generates a clone). For cryptographic PRNGs this is not a problem;
for others it is recommended to seed from a different type of generator.
<a href="../rand/rand_chacha/struct.ChaCha8Rng.html"><code>ChaCha8Rng</code></a> is an excellent choice for a deterministic master generator
(but for cryptographic uses, prefer the 12-round variant or higher).</p>
<h3><a class="header" href="#a-simple-number" id="a-simple-number">A simple number</a></h3>
<p>For some applications, especially simulations, all you want are a sequence of
distinct, fixed random number seeds, e.g. 1, 2, 3, etc.</p>
<p><a href="../rand/rand_core/trait.SeedableRng.html#method.seed_from_u64"><code>SeedableRng::seed_from_u64</code></a> is designed exactly for this use-case.
Internally, it uses a simple PRNG to fill the bits of the seed from the input
number while providing good bit-avalance (so that two similar numbers such as
0 and 1 translate to very different seeds and independent RNG sequences).</p>
<pre><pre class="playground"><code class="language-rust editable">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rand::prelude::*;
use rand_pcg::Pcg64;

let rng = Pcg64::seed_from_u64(2);
<span class="boring">}
</span></code></pre></pre>
<p>Note that a number with 64-bits or less <strong>cannot be secure</strong>, so this should
not be used for applications such as cryptography or gambling games.</p>
<h3><a class="header" href="#a-string-or-any-hashable-data" id="a-string-or-any-hashable-data">A string, or any hashable data</a></h3>
<p>Say you let users enter a string to seed the random number generator. Ideally,
all parts of the string should influence the generator and making only a small
change to the string should result in a fully independent generator sequence.</p>
<p>This can be achieved via use of a hash function to compress all input data down
to a hash result, then using that result to seed a generator. The
<a href="https://github.com/rust-random/seeder/"><code>rand_seeder</code></a> crate is designed for just this purpose.</p>
<pre><pre class="playground"><code class="language-rust editable">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rand::prelude::*;
use rand_seeder::{Seeder, SipHasher};
use rand_pcg::Pcg64;

// In one line:
let rng: Pcg64 = Seeder::from(&quot;stripy zebra&quot;).make_rng();

// If we want to be more explicit, first we create a SipRng:
let hasher = SipHasher::from(&quot;a sailboat&quot;);
let mut hasher_rng = hasher.into_rng();
// (Note: hasher_rng is a full RNG and can be used directly.)

// Now, we use hasher_rng to create a seed:
let mut seed: &lt;Pcg64 as SeedableRng&gt;::Seed = Default::default();
hasher_rng.fill(&amp;mut seed);

// And create our RNG from that seed:
let rng = Pcg64::from_seed(seed);
<span class="boring">}
</span></code></pre></pre>
<p>Note that <code>rand_seeder</code> is <strong>not suitable</strong> for cryptographic usage.
It is <strong>not a password hasher</strong>, for such applications a key-derivation
function such as Argon2 must be used.</p>
<h1><a class="header" href="#random-values" id="random-values">Random values</a></h1>
<p>Now that we have a way of producing random data, how can we convert it to the
type of value we want?</p>
<p>This is a trick question: we need to know both the <em>range</em> we want and the type
of <em>distribution</em> of this value (which is what the <a href="guide-dist.html"><code>next</code></a> section
is all about).</p>
<h2><a class="header" href="#the-rng-trait" id="the-rng-trait">The <code>Rng</code> trait</a></h2>
<p>For convenience, all generators automatically implement the <a href="../rand/rand/trait.Rng.html"><code>Rng</code></a> trait,
which provides short-cuts to a few ways of generating values. This has several
convenience functions for producing uniformly distributed values:</p>
<ul>
<li>
<p><a href="../rand/rand/trait.Rng.html#method.gen"><code>Rng::gen</code></a> generates an unbiased (uniform) random value from a range
appropriate for the
type. For integers this is normally the full representable range
(e.g. from <code>0u32</code> to <code>std::u32::MAX</code>), for floats this is between 0 and 1,
and some other types are supported, including arrays and tuples.</p>
<p>This method is a convenience wrapper around the <a href="../rand/rand/distributions/struct.Standard.html"><code>Standard</code></a> distribution,
as documented in the <a href="guide-dist.html#uniform-distributions">next section</a>.</p>
</li>
<li>
<p><a href="../rand/rand/trait.Rng.html#method.gen_range"><code>Rng::gen_range</code></a> generates an unbiased random value with given bounds
<code>low</code> (inclusive) and <code>high</code> (exclusive)</p>
</li>
<li>
<p><a href="../rand/rand/trait.Rng.html#method.fill"><code>Rng::fill</code></a> and <a href="../rand/rand/trait.Rng.html#method.try_fill"><code>Rng::try_fill</code></a> are optimised functions for filling any byte or
integer slice with random values</p>
</li>
</ul>
<p>It also has convenience functions for producing non-uniform boolean values:</p>
<ul>
<li><a href="../rand/rand/trait.Rng.html#method.gen_bool"><code>Rng::gen_bool</code></a> generates a boolean with the given probability</li>
<li><a href="../rand/rand/trait.Rng.html#method.gen_ratio"><code>Rng::gen_ratio</code></a> also generates a boolean, where the probability is defined
via a fraction</li>
</ul>
<p>Finally, it has a function to sample from arbitrary distributions:</p>
<ul>
<li><a href="../rand/rand/trait.Rng.html#method.sample"><code>Rng::sample</code></a> samples directly from some <a href="guide-dist.html">distribution</a></li>
</ul>
<p>Examples:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate rand;
</span>use rand::Rng;
let mut rng = rand::thread_rng();

// an unbiased integer over the entire range:
let i: i32 = rng.gen();

// a uniformly distributed value between 0 and 1:
let x: f64 = rng.gen();

// simulate rolling a die:
let roll = rng.gen_range(1, 7);
<span class="boring">}
</span></code></pre></pre>
<p>Additionally, the <a href="../rand/rand/fn.random.htm"><code>random</code></a> function is a short-cut to <a href="../rand/rand/trait.Rng.html#method.gen"><code>Rng::gen</code></a> on the <a href="../rand/rand/fn.thread_rng.html"><code>thread_rng</code></a>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if rand::random() {
    println!(&quot;we got lucky!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#random-distributions" id="random-distributions">Random distributions</a></h1>
<p>For maximum flexibility when producing random values, we define the
<a href="../rand/rand/distributions/trait.Distribution.html"><code>Distribution</code></a> trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// a producer of data of type T:
pub trait Distribution&lt;T&gt; {
    // the key function:
    fn sample&lt;R: Rng + ?Sized&gt;(&amp;self, rng: &amp;mut R) -&gt; T;

    // a convenience function defined using sample:
    fn sample_iter&lt;R&gt;(self, rng: R) -&gt; DistIter&lt;Self, R, T&gt;
    where
        Self: Sized,
        R: Rng,
    { ... }
}
<span class="boring">}
</span></code></pre></pre>
<p>Rand provides implementations of many different distributions; we cover the most
common of these here, but for full details refer to the <a href="../rand/rand/distributions/index.html"><code>distributions</code></a> module
and the <a href="../rand/rand_distr/index.html"><code>rand_distr</code></a> crate.</p>
<h1><a class="header" href="#uniform-distributions" id="uniform-distributions">Uniform distributions</a></h1>
<p>The most obvious type of distribution is the one we already discussed: one
without pattern, where each value or range of values is equally likely. This is
known as <em>uniform</em>.</p>
<p>Rand actually has several variants of this, repesenting different ranges:</p>
<ul>
<li><a href="../rand/rand/distributions/struct.Standard.html"><code>Standard</code></a> requires no parameters and samples values uniformly according
to the type. <a href="../rand/rand/trait.Rng.html#method.gen"><code>Rng::gen</code></a> provides a short-cut to this distribution.</li>
<li><a href="../rand/rand/distributions/struct.Uniform.html"><code>Uniform</code></a> is parametrised by <code>Uniform::new(low, high)</code> (including <code>low</code>,
excluding <code>high</code>) or <code>Uniform::new_inclusive(low, high)</code> (including both),
and samples values uniformly within this range.
<a href="../rand/rand/trait.Rng.html#method.gen_range"><code>Rng::gen_range</code></a> is a convenience method defined over
<a href="../rand/rand/distributions/struct.Uniform.html#method.sample_single"><code>Uniform::sample_single</code></a>, optimised for single-sample usage.</li>
<li><a href="../rand/rand/distributions/struct.Alphanumeric.html"><code>Alphanumeric</code></a> is uniform over the <code>char</code> values <code>0-9A-Za-z</code>.</li>
<li><a href="../rand/rand/distributions/struct.Open01.html"><code>Open01</code></a> and <a href="../rand/rand/distributions/struct.OpenClosed01.html"><code>OpenClosed01</code></a> are provide alternate sampling ranges for
floating-point types (see below).</li>
</ul>
<h2><a class="header" href="#uniform-sampling-by-type" id="uniform-sampling-by-type">Uniform sampling by type</a></h2>
<p>Lets go over the distributions by type:</p>
<ul>
<li>
<p>For <code>bool</code>, <a href="../rand/rand/distributions/struct.Standard.html"><code>Standard</code></a> samples each value with probability 50%.</p>
</li>
<li>
<p>For <code>Option&lt;T&gt;</code>, the <a href="../rand/rand/distributions/struct.Standard.html"><code>Standard</code></a> distribution samples <code>None</code> with
probability 50%, otherwise <code>Some(value)</code> is sampled, according to its type.</p>
</li>
<li>
<p>For integers (<code>u8</code> through to <code>u128</code>, <code>usize</code>, and <code>i*</code> variants),
<a href="../rand/rand/distributions/struct.Standard.html"><code>Standard</code></a> samples from all possible values while
<a href="../rand/rand/distributions/struct.Uniform.html"><code>Uniform</code></a> samples from the parameterised range.</p>
</li>
<li>
<p>For <code>NonZeroU8</code> and other &quot;non-zero&quot; types, <a href="../rand/rand/distributions/struct.Standard.html"><code>Standard</code></a> samples uniformly
from all non-zero values (rejection method).</p>
</li>
<li>
<p><code>Wrapping&lt;T&gt;</code> integer types are sampled as for the corresponding integer
type by the <a href="../rand/rand/distributions/struct.Standard.html"><code>Standard</code></a> distribution.</p>
</li>
<li>
<p>For floats (<code>f32</code>, <code>f64</code>),</p>
<ul>
<li><a href="../rand/rand/distributions/struct.Standard.html"><code>Standard</code></a> samples from the half-open range <code>[0, 1)</code> with 24 or 53
bits of precision (for <code>f32</code> and <code>f64</code> respectively)</li>
<li><a href="../rand/rand/distributions/struct.OpenClosed01.html"><code>OpenClosed01</code></a> samples from the half-open range <code>(0, 1]</code> with 24 or
53 bits of precision</li>
<li><a href="../rand/rand/distributions/struct.Open01.html"><code>Open01</code></a> samples from the open range <code>(0, 1)</code> with 23 or 52 bits of
precision</li>
<li><a href="../rand/rand/distributions/struct.Uniform.html"><code>Uniform</code></a> samples from a given range with 23 or 52 bits of precision</li>
</ul>
</li>
<li>
<p>For the <code>char</code> type, the <a href="../rand/rand/distributions/struct.Standard.html"><code>Standard</code></a> distribution samples from all
available Unicode code points, uniformly; many of these values may not be
printable (depending on font support). The <a href="../rand/rand/distributions/struct.Alphanumeric.html"><code>Alphanumeric</code></a> samples from
only a-z, A-Z and 0-9 uniformly.</p>
</li>
<li>
<p>For tuples and arrays, each element is sampled as above, where supported.
The <a href="../rand/rand/distributions/struct.Standard.html"><code>Standard</code></a> and <a href="../rand/rand/distributions/struct.Uniform.html"><code>Uniform</code></a> distributions each support a selection of
these types (up to 12-tuples and 32-element arrays).
This includes the empty tuple <code>()</code> and array.</p>
</li>
<li>
<p>For SIMD types, each element is sampled as above, for <a href="../rand/rand/distributions/struct.Standard.html"><code>Standard</code></a> and
<a href="../rand/rand/distributions/struct.Uniform.html"><code>Uniform</code></a> (for the latter, <code>low</code> and <code>high</code> parameters are <em>also</em> SIMD
types, effectively sampling from multiple ranges simultaneously). SIMD
support is gated behind a <a href="../features.html#simd-support">feature flag</a>.</p>
</li>
</ul>
<h1><a class="header" href="#non-uniform-distributions" id="non-uniform-distributions">Non-uniform distributions</a></h1>
<p>Non-uniform distributions can be divided into two categories, as follows.
Some of these discrete and all of the continuous distributions have been moved
from the main <a href="../rand/rand/index.html"><code>rand</code></a> crate to a dedicated <a href="../rand/rand_distr/index.html"><code>rand_distr</code></a> crate.</p>
<h2><a class="header" href="#discrete-non-uniform-distributions" id="discrete-non-uniform-distributions">Discrete non-uniform distributions</a></h2>
<p>Discrete distributions sample from boolean or integer types. As above, these
can be sampled uniformly, or, as below, via a non-uniform distribution.</p>
<p>Potentially a discrete distribution could sample directly from a set of discrete
values such as a slice or an <code>enum</code>. See the section on <a href="../guide-seq.html">Sequences</a> regarding
Rand's traits for slice and iterator types. Rand does not provide direct
sampling from <code>enum</code>s, with the exception of <code>Option</code> (see above).</p>
<h3><a class="header" href="#booleans" id="booleans">Booleans</a></h3>
<p>The <a href="../rand/rand/distributions/struct.Bernoulli.html"><code>Bernoulli</code></a> distribution is a fancy name for generating a boolean
with a given a probability <code>p</code> of being <code>true</code>, or defined via a
<code>success : failure</code> ratio. Often this is described as a <em>trial</em> with
probability <code>p</code> of <em>success</em> (<code>true</code>).</p>
<p>The methods <a href="../rand/rand/trait.Rng.html#method.gen_bool"><code>Rng::gen_bool</code></a> and <a href="../rand/rand/trait.Rng.html#method.gen_ratio"><code>Rng::gen_ratio</code></a> are short-cuts to this
distribution.</p>
<h3><a class="header" href="#integers" id="integers">Integers</a></h3>
<p>The <a href="../rand/rand/distributions/struct.Binomial.html"><code>Binomial</code></a> distribution is related to the <a href="../rand/rand/distributions/struct.Bernoulli.html"><code>Bernoulli</code></a> in that it
models running <code>n</code> independent trials each with probability <code>p</code> of success,
then counts the number of successes.</p>
<p>Note that for large <code>n</code> the <a href="../rand/rand/distributions/struct.Binomial.html"><code>Binomial</code></a> distribution's implementation is
much faster than sampling <code>n</code> trials individually.</p>
<p>The <a href="../rand/rand/distributions/struct.Poisson.html"><code>Poisson</code></a> distribution expresses the expected number of events
occurring within a fixed interval, given that events occur with fixed rate λ.</p>
<h3><a class="header" href="#weighted-sequences" id="weighted-sequences">Weighted sequences</a></h3>
<p>The <a href="../rand/rand/distributions/weighted/struct.WeightedIndex.html"><code>WeightedIndex</code></a> distribution samples an index from sequence of weights.
See the <a href="../guide-seq.html">Sequences</a> section for convenience wrappers directly sampling a slice
element.</p>
<p>For example, weighted sampling could be used to model the colour of a marble
sampled from a bucket containing 5 green, 15 red and 80 blue marbles.</p>
<p>Currently the Rand lib only implements <em>sampling with replacement</em>, i.e.
repeated sampling assumes the same distribution (that any sampled marble
has been replaced). An alternative distribution implementing
<em>sampling without replacement</em> has been
<a href="https://github.com/rust-random/rand/issues/596">requested</a>.</p>
<p>Note also that two implementations of <a href="../rand/rand/distributions/weighted/struct.WeightedIndex.html"><code>WeightedIndex</code></a> are available; the
first is optimised for a small number of samples while
<a href="../rand/rand/distributions/weighted/alias_method/struct.WeightedIndex.html"><code>alias_method::WeightedIndex</code></a> is optimised for a large number of samples
(where &quot;large&quot; may mean &quot;&gt; 1000&quot;; benchmarks recommended).</p>
<h2><a class="header" href="#continuous-non-uniform-distributions" id="continuous-non-uniform-distributions">Continuous non-uniform distributions</a></h2>
<p>Continuous distributions model samples drawn from the real number line ℝ, or in
some cases a point from a higher dimension (ℝ², ℝ³, etc.). We provide
implementations for <code>f64</code> and for <code>f32</code> output in most cases, although currently
the <code>f32</code> implementations simply reduce the precision of an <code>f64</code> sample.</p>
<p>The exponential distribution, <a href="../rand/rand/distributions/struct.Exp.html"><code>Exp</code></a>, simulates time until decay, assuming a
fixed rate of decay (i.e. exponential decay).</p>
<p>The <a href="../rand/rand/distributions/struct.Normal.html"><code>Normal</code></a> distribution (also known as Gaussian) simulates sampling from
the Normal distribution (&quot;Bell curve&quot;) with the given mean and standard
deviation. The <a href="../rand/rand/distributions/struct.LogNormal.html"><code>LogNormal</code></a> is related: for sample <code>X</code> from the log-normal
distribution, <code>log(X)</code> is normally distributed; this &quot;skews&quot; the normal
distribution to avoid negative values and to have a long positive tail.</p>
<p>The <a href="../rand/rand/distributions/struct.UnitCircle.html"><code>UnitCircle</code></a> and <a href="../rand/rand/distributions/struct.UnitSphereSurface.html"><code>UnitSphereSurface</code></a> distributions simulate uniform
sampling from the edge of a circle or surface of a sphere.</p>
<p>The <a href="../rand/rand/distributions/struct.Cauchy.html"><code>Cauchy</code></a> distribution (also known as the Lorentz distribution) is the
distribution of the x-intercept of a ray from point <code>(x0, γ)</code> with uniformly
distributed angle.</p>
<p>The <a href="../rand/rand/distributions/struct.Beta.html"><code>Beta</code></a> distribution is a two-parameter probability distribution, whose
output values lie between 0 and 1. The <a href="../rand/rand/distributions/struct.Dirichlet.html"><code>Dirichlet</code></a> distribution is a
generalisation to any positive number of parameters.</p>
<h1><a class="header" href="#sequences" id="sequences">Sequences</a></h1>
<p>Rand implements a few common random operations on sequences via the
<a href="../rand/rand/seq/trait.IteratorRandom.html"><code>IteratorRandom</code></a> and <a href="../rand/rand/seq/trait.SliceRandom.html"><code>SliceRandom</code></a> traits:</p>
<ul>
<li><code>choose</code> one element uniformly from the sequence</li>
<li><code>choose_multiple</code> elements uniformly without replacement</li>
<li><code>choose_weighted</code> — choose an element non-uniformly by use of a defined
weight from a slice (also see the <a href="../rand/rand/distributions/struct.WeightedIndex.html"><code>WeightedIndex</code></a> distribution)</li>
<li><code>shuffle</code> a slice</li>
<li><code>partial_shuffle</code> a slice, effectively extracting <code>amount</code> elements in
random order</li>
</ul>
<h1><a class="header" href="#error-handling" id="error-handling">Error handling</a></h1>
<p>Error handling in Rand is a compromise between simplicity and necessity.
Most RNGs and sampling functions will never produce errors, and making these
able to handle errors would add significant overhead (to code complexity
and ergonomics of usage at least, and potentially also performance,
depending on the approach).
However, external RNGs can fail, and being able to handle this is important.</p>
<p>It has therefore been decided that <em>most</em> methods should not return a
<code>Result</code> type, but with a few important exceptions, namely:</p>
<ul>
<li><a href="../rand/rand/trait.Rng.html#method.try_fill"><code>Rng::try_fill</code></a></li>
<li><a href="../rand/rand_core/trait.RngCore.html#tymethod.try_fill_bytes"><code>RngCore::try_fill_bytes</code></a></li>
<li><a href="../rand/rand_core/trait.SeedableRng.html#method.from_rng"><code>SeedableRng::from_rng</code></a></li>
</ul>
<p>Most functions consuming random values will not attempt any error handling, and
reduce to calls to <a href="../rand/rand_core/trait.RngCore.html"><code>RngCore</code></a>'s &quot;infallible&quot; methods. Since most RNGs cannot
fail anyway this is usually not a problem, but the few generators which can may
be forced to fail in this case:</p>
<ul>
<li><a href="../rand/rand/rngs/struct.OsRng.html"><code>OsRng</code></a> interfaces with the Operating System's generator; in rare cases
this may fail as &quot;not ready&quot; or simply &quot;unavailable&quot;.</li>
<li><a href="../rand/rand/rngs/struct.JitterRng.html"><code>JitterRng</code></a> is a generator based on timer jitter; if the timer does not
appear to be capable of sufficient precision or is too predictable, this
will fail.</li>
<li><a href="../rand/rand/rngs/struct.EntropyRng.html"><code>EntropyRng</code></a> is an abstraction over the above, falling back to the next
option when the first fails but ultimately failing if all sources fail</li>
<li><a href="../rand/rand/fn.thread_rng.html"><code>thread_rng</code></a> seeds itself via <a href="../rand/rand/rngs/struct.EntropyRng.html"><code>EntropyRng</code></a>, thus can potentially fail
on its first use on each thread (though it never fails after the first use)</li>
<li><a href="../rand/rand/rngs/adapter/struct.ReadRng.html"><code>ReadRng</code></a> tries to read data from its source but fails when the stream
ends or errors (though it retries on interrupt).</li>
</ul>
<h1><a class="header" href="#portability" id="portability">Portability</a></h1>
<h2><a class="header" href="#definitions" id="definitions">Definitions</a></h2>
<p>Given fixed inputs, all items (should) fall into one of three categories:</p>
<ul>
<li>Output is non-deterministic, thus never reproducible</li>
<li>Output is deterministic, but not considered portable</li>
<li>Output is deterministic and portable</li>
</ul>
<p>In general, functionality is considered deterministic and portable <em>unless</em>
it is clearly non-deterministic (e.g. <code>getrandom</code>, <code>ThreadRng</code>) <em>or</em> it is
documented as being unportable (e.g. <code>StdRng</code>, <code>SmallRng</code>).</p>
<h2><a class="header" href="#crate-versions" id="crate-versions">Crate versions</a></h2>
<p>We try to follow <a href="https://docs.npmjs.com/misc/semver">semver rules</a> regarding
API-breaking changes and <code>MAJOR.MINOR.PATCH</code> versions:</p>
<ul>
<li>New <em>patch</em> versions should not include API-breaking changes or major new
features</li>
<li>Before 1.0, <em>minor</em> versions may include API breaking changes. After 1.0
they should not.</li>
</ul>
<p>Additionally, we must also consider <em>value-breaking changes</em> and <em>portability</em>.
When given fixed inputs,</p>
<ul>
<li>For non-deterministic items, implementations may change in any release</li>
<li>For deterministic unportable items, output should be preserved in patch
releases, but may change in any minor release (including after 1.0)</li>
<li>For portable items, any change of output across versions is considered
equivalent to an API breaking change.</li>
</ul>
<h3><a class="header" href="#testing" id="testing">Testing</a></h3>
<p>We expect all pseudo-random algorithms to test the value-stability of their
output, where possible:</p>
<ul>
<li>PRNGs should be compared with a reference vector (<a href="https://github.com/rust-random/rngs/blob/master/rand_xoshiro/src/xoshiro256starstar.rs#L113">example</a>)</li>
<li>Other algorithms should include their own test vectors within a
<code>value_stability</code> test or similar (<a href="https://github.com/rust-random/rand/blob/master/src/distributions/bernoulli.rs#L168">example</a>)</li>
</ul>
<h2><a class="header" href="#limitations" id="limitations">Limitations</a></h2>
<h3><a class="header" href="#portability-of-usize" id="portability-of-usize">Portability of usize</a></h3>
<p>There is unfortunately one non-portable item baked into the heart of the Rust
language: <code>usize</code> (and <code>isize</code>). For example, the size of an empty
<code>Vec</code> will differ on 32-bit and 64-bit targets. For most purposes this is not an
issue, but when it comes to generating random numbers in a portable manner
it does matter.</p>
<p>A simple rule follows: if portability is required, <em>never</em> sample a <code>usize</code> or
<code>isize</code> value directly.</p>
<p>Within Rand we adhere to this rule whenever possible. All sequence-releated
code requiring a bounded <code>usize</code> value will sample a <code>u32</code> value unless the
upper bound exceeds <code>u32::MAX</code>.
(Note that this actually improves benchmark performance in many cases.)</p>
<h3><a class="header" href="#portability-of-floats" id="portability-of-floats">Portability of floats</a></h3>
<p>The results of floating point arithmetic depend on rounding modes and
implementation details. Especially the results of transcendental functions vary
from platform to platform. Due to this, the distributions in <code>rand_distr</code> are
not always portable for <code>f32</code> and <code>f64</code>. However, we strive to make them as
portable as possible.</p>
<h1><a class="header" href="#updating" id="updating">Updating</a></h1>
<p>This guide is intended to facilitate upgrading to the next minor or major
version of Rand. Note that updating to the next patch version (e.g. 0.5.1 to
0.5.2) should never require code changes.</p>
<p>This guide gives a few more details than the <a href="https://github.com/rust-random/rand/blob/master/CHANGELOG.md">changelog</a>, in particular giving
guidance on how to use new features and migrate away from old ones.</p>
<h1><a class="header" href="#updating-to-05" id="updating-to-05">Updating to 0.5</a></h1>
<p>The 0.5 release has quite significant changes over the 0.4 release; as such,
it may be worth reading through the following coverage of breaking changes.
This release also contains many optimisations, which are not detailed below.</p>
<h2><a class="header" href="#crates" id="crates">Crates</a></h2>
<p>We have a new crate: <code>rand_core</code>! This crate houses some important traits,
<code>RngCore</code>, <code>BlockRngCore</code>, <code>SeedableRng</code> and <code>CryptoRng</code>, the error types, as
well as two modules with helpers for implementations: <code>le</code> and <code>impls</code>. It is
recommended that implementations of generators use the <code>rand_core</code> crate while
other users use only the <code>rand</code> crate, which re-exports most parts of <code>rand_core</code>.</p>
<p>The <code>rand_derive</code> crate has been deprecated due to very low usage and
deprecation of <code>Rand</code>.</p>
<h2><a class="header" href="#features" id="features">Features</a></h2>
<p>Several new Cargo feature flags have been added:</p>
<ul>
<li><code>alloc</code>, used without <code>std</code>, allows use of <code>Box</code> and <code>Vec</code></li>
<li><code>serde1</code> adds serialization support to some PRNGs</li>
<li><code>log</code> adds logging in a few places (primarily to <code>OsRng</code> and <code>JitterRng</code>)</li>
</ul>
<h2><a class="header" href="#rng-and-friends-core-traits" id="rng-and-friends-core-traits"><code>Rng</code> and friends (core traits)</a></h2>
<p><code>Rng</code> trait has been split into two traits, a &quot;back end&quot; <code>RngCore</code> (implemented
by generators) and a &quot;front end&quot; <code>Rng</code> implementing all the convenient extension
methods.</p>
<p>Implementations of generators must <code>impl RngCore</code> instead. Usage of <code>rand_core</code>
for implementations is encouraged; the <code>rand_core::{le, impls}</code> modules may
prove useful.</p>
<p>Users of <code>Rng</code> <em>who don't need to implement it</em> won't need to make so many
changes; often users can forget about <code>RngCore</code> and only import <code>Rng</code>. Instead
of <code>RngCore::next_u32()</code> / <code>next_u64()</code> users should prefer <code>Rng::gen()</code>, and
instead of <code>RngCore::fill_bytes(dest)</code>, <code>Rng::fill(dest)</code> can be used.</p>
<h3><a class="header" href="#rng--rngcore-methods" id="rng--rngcore-methods"><code>Rng</code> / <code>RngCore</code> methods</a></h3>
<p>To allow error handling from fallible sources (e.g. <code>OsRng</code>), a new
<code>RngCore::try_fill_bytes</code> method has been added; for example <code>EntropyRng</code> uses
this mechanism to fall back to <code>JitterRng</code> if <code>OsRng</code> fails, and various
handlers produce better error messages.
As before, the other methods will panic on failure, but since these are usually
used with algorithmic generators which are usually infallible, this is
considered an appropriate compromise.</p>
<p>A few methods from the old <code>Rng</code> have been removed or deprecated:</p>
<ul>
<li><code>next_f32</code> and <code>next_f64</code>; these are no longer implementable by generators;
use <code>gen</code> instead</li>
<li><code>gen_iter</code>; users may instead use standard iterators with closures:
<code>::std::iter::repeat(()).map(|()| rng.gen())</code></li>
<li><code>gen_ascii_chars</code>; use <code>repeat</code> as above and <code>rng.sample(Alphanumeric)</code></li>
<li><code>gen_weighted_bool(n)</code>; use <code>gen_bool(1.0 / n)</code> instead</li>
</ul>
<p><code>Rng</code> has a few new methods:</p>
<ul>
<li><code>sample(distr)</code> is a shortcut for <code>distr.sample(rng)</code> for any <code>Distribution</code></li>
<li><code>gen_bool(p)</code> generates a boolean with probability <code>p</code> of being true</li>
<li><code>fill</code> and <code>try_fill</code>, corresponding to <code>fill_bytes</code> and <code>try_fill_bytes</code>
respectively (i.e. the only difference is error handling); these can fill
and integer slice / array directly, and provide better performance
than <code>gen()</code></li>
</ul>
<h3><a class="header" href="#constructing-prngs" id="constructing-prngs">Constructing PRNGs</a></h3>
<h4><a class="header" href="#new-randomly-initialised-prngs" id="new-randomly-initialised-prngs">New randomly-initialised PRNGs</a></h4>
<p>A new trait has been added: <code>FromEntropy</code>. This is automatically implemented for
any type supporting <code>SeedableRng</code>, and provides construction from fresh, strong
entropy:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rand::{ChaChaRng, FromEntropy};

let mut rng = ChaChaRng::from_entropy();
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#seeding-prngs" id="seeding-prngs">Seeding PRNGs</a></h4>
<p>The <code>SeedableRng</code> trait has been modified to include the seed type via an
associated type (<code>SeedableRng::Seed</code>) instead of a template parameter
(<code>SeedableRng&lt;Seed&gt;</code>). Additionally, all PRNGs now seed from a byte-array
(<code>[u8; N]</code> for some fixed N). This allows generic handling of PRNG seeding
which was not previously possible.</p>
<p>PRNGs are no longer constructed from other PRNGs via <code>Rand</code> support / <code>gen()</code>,
but through <code>SeedableRng::from_rng</code>, which allows error handling and is
intentionally explicit.</p>
<p><code>SeedableRng::reseed</code> has been removed since it has no utility over <code>from_seed</code>
and its performance advantage is questionable.</p>
<p>Implementations of <code>SeedableRng</code> may need to change their <code>Seed</code> type to a
byte-array; this restriction has been made to ensure portable handling of
Endianness. Helper functions are available in <code>rand_core::le</code> to read <code>u32</code> and
<code>u64</code> values from byte arrays.</p>
<h3><a class="header" href="#block-based-prngs" id="block-based-prngs">Block-based PRNGs</a></h3>
<p>rand_core has a new helper trait, <code>BlockRngCore</code>, and implementation,
<code>BlockRng</code>. These are for use by generators which generate a block of random
data at a time instead of word-sized values. Using this trait and implementation
has two advantages: optimised <code>RngCore</code> methods are provided, and the PRNG can
be used with <code>ReseedingRng</code> with very low overhead.</p>
<h3><a class="header" href="#cryptographic-rngs" id="cryptographic-rngs">Cryptographic RNGs</a></h3>
<p>A new trait has been added: <code>CryptoRng</code>. This is purely a marker trait to
indicate which generators should be suitable for cryptography, e.g.
<code>fn foo&lt;R: Rng + CryptoRng&gt;(rng: &amp;mut R)</code>. <em>Suitability for cryptographic
use cannot be guaranteed.</em></p>
<h2><a class="header" href="#error-handling-1" id="error-handling-1">Error handling</a></h2>
<p>A new <code>Error</code> type has been added, designed explicitly for no-std compatibility,
simplicity, and enough flexibility for our uses (carrying a <code>cause</code> when
possible):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Error {
    pub kind: ErrorKind,
    pub msg: &amp;'static str,
    // some fields omitted
}
<span class="boring">}
</span></code></pre></pre>
<p>The associated <code>ErrorKind</code> allows broad classification of errors into permanent,
unexpected, transient and not-yet-ready kinds.</p>
<p>The following use the new error type:</p>
<ul>
<li><code>RngCore::try_fill_bytes</code></li>
<li><code>Rng::try_fill</code></li>
<li><code>OsRng::new</code></li>
<li><code>JitterRng::new</code></li>
</ul>
<h2><a class="header" href="#external-generators" id="external-generators">External generators</a></h2>
<p>We have a new generator, <code>EntropyRng</code>, which wraps <code>OsRng</code> and <code>JitterRng</code>
(preferring to use the former, but falling back to the latter if necessary).
This allows easy construction with fallback via <code>SeedableRng::from_rng</code>,
e.g. <code>IsaacRng::from_rng(EntropyRng::new())?</code>. This is equivalent to using
<code>FromEntropy</code> except for error handling.</p>
<p>It is recommended to use <code>EntropyRng</code> over <code>OsRng</code> to avoid errors on platforms
with broken system generator, but it should be noted that the <code>JitterRng</code>
fallback is very slow.</p>
<h2><a class="header" href="#prngs" id="prngs">PRNGs</a></h2>
<p><em>Pseudo-Random Number Generators</em> (i.e. deterministic algorithmic generators)
have had a few changes since 0.4, and are now housed in the <code>prng</code> module
(old names remain temporarily available for compatibility; eventually these
generators will likely be housed outside the <code>rand</code> crate).</p>
<p>All PRNGs now do not implement <code>Copy</code> to prevent accidental copying of the
generator's state (and thus repetitions of generated values). Explicit cloning
via <code>Clone</code> is still available. All PRNGs now have a custom implementation of
<code>Debug</code> which does not print any internal state; this helps avoid accidentally
leaking cryptographic generator state in log files. External PRNG
implementations are advised to follow this pattern (see also doc on <code>RngCore</code>).</p>
<p><code>SmallRng</code> has been added as a wrapper, currently around <code>XorShiftRng</code> (but
likely another algorithm soon). This is for uses where small state and fast
initialisation are important but cryptographic strength is not required.
(Actual performance of generation varies by benchmark; depending on usage
this may or may not be the fastest algorithm, but will always be fast.)</p>
<h3><a class="header" href="#reseedingrng" id="reseedingrng"><code>ReseedingRng</code></a></h3>
<p>The <code>ReseedingRng</code> wrapper has been significantly altered to reduce overhead.
Unfortunately the new <code>ReseedingRng</code> is not compatible with all RNGs, but only
those using <code>BlockRngCore</code>.</p>
<h3><a class="header" href="#chacha" id="chacha">ChaCha</a></h3>
<p>The method <code>ChaChaRng::set_counter</code> has been replaced by two new methods,
<code>set_word_pos</code> and <code>set_stream</code>. Where necessary, the behaviour of the old
method may be emulated as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use rand::prelude::*;
</span><span class="boring">use rand_chacha::ChaChaRng;
</span>let lower = 88293;
let higher = 9300932;

// previously:
// let mut rng = rand::ChaChaRng::new_unseeded();
// rng.set_counter(lower, higher);

// now:
let mut rng = ChaChaRng::from_seed([0u8; 32]);
rng.set_word_pos(lower &lt;&lt; 4);
rng.set_stream(higher);

assert_eq!(4060232610, rng.next_u32());
assert_eq!(2786236710, rng.next_u32());
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#isaac-prngs" id="isaac-prngs">ISAAC PRNGs</a></h3>
<p>The <code>IsaacRng</code> and <code>Isaac64Rng</code> PRNGs now have an additional construction
method: <code>new_from_u64(seed)</code>. 64 bits of state is insufficient for cryptography
but may be of use in simulations and games. This will likely be superseded by
a method to construct any PRNG from any hashable object in the future.</p>
<h3><a class="header" href="#hc-128" id="hc-128">HC-128</a></h3>
<p>This is a new cryptographic generator, selected as one of the &quot;stream ciphers
suitable for widespread adoption&quot; by eSTREAM. This is now the default
cryptographic generator, used by <code>StdRng</code> and <code>thread_rng()</code>.</p>
<h2><a class="header" href="#helper-functionstraits" id="helper-functionstraits">Helper functions/traits</a></h2>
<p>The <code>Rand</code> trait has been deprecated. Instead, users are encouraged to use
<code>Standard</code> which is a real distribution and supports the same sampling as
<code>Rand</code>. <code>Rng::gen()</code> now uses <code>Standard</code> and should work exactly as before.
See the documentation of the <code>distributions</code> module on how to implement
<code>Distribution&lt;T&gt;</code> for <code>Standard</code> for user types <code>T</code></p>
<p><code>weak_rng()</code> has been deprecated; use <code>SmallRng::from_entropy()</code> instead.</p>
<h2><a class="header" href="#distributions-1" id="distributions-1">Distributions</a></h2>
<p>The <code>Sample</code> and <code>IndependentSample</code> traits have been replaced by a single
trait, <code>Distribution</code>. This is largely equivalent to <code>IndependentSample</code>, but
with <code>ind_sample</code> replaced by just <code>sample</code>. Support for mutable distributions
has been dropped; although it appears there may be a few genuine uses, these
are not used widely enough to justify the existence of two independent traits
or of having to provide mutable access to a distribution object. Both <code>Sample</code>
and <code>IndependentSample</code> are still available, but deprecated; they will be
removed in a future release.</p>
<p><code>Distribution::sample</code> (as well as several other functions) can now be called
directly on type-erased (unsized) RNGs.</p>
<p><code>RandSample</code> has been removed (see <code>Rand</code> deprecation and new <code>Standard</code>
distribution).</p>
<p>The <code>Closed01</code> wrapper has been removed, but <code>OpenClosed01</code> has been added.</p>
<h3><a class="header" href="#uniform-distributions-1" id="uniform-distributions-1">Uniform distributions</a></h3>
<p>Two new distributions are available:</p>
<ul>
<li><code>Standard</code> produces uniformly-distributed samples for many different types,
and acts as a replacement for <code>Rand</code></li>
<li><code>Alphanumeric</code> samples <code>char</code>s from the ranges <code>a-z A-Z 0-9</code></li>
</ul>
<h4><a class="header" href="#ranges" id="ranges">Ranges</a></h4>
<p>The <code>Range</code> distribution has been heavily adapted, and renamed to <code>Uniform</code>:</p>
<ul>
<li><code>Uniform::new(low, high)</code> remains (half open <code>[low, high)</code>)</li>
<li><code>Uniform::new_inclusive(low, high)</code> has been added, including <code>high</code> in the sample range</li>
<li><code>Uniform::sample_single(low, high, rng)</code> is a faster variant for single usage sampling from <code>[low, high)</code></li>
</ul>
<p><code>Uniform</code> can now be implemented for user-defined types; see the <code>uniform</code> module.</p>
<h3><a class="header" href="#non-uniform-distributions-1" id="non-uniform-distributions-1">Non-uniform distributions</a></h3>
<p>Two distributions have been added:</p>
<ul>
<li>Poisson, modeling the number of events expected from a constant-rate
source within a fixed time interval (e.g. nuclear decay)</li>
<li>Binomial, modeling the outcome of a fixed number of yes-no trials</li>
</ul>
<p>The sampling methods are based on those in &quot;Numerical Recipes in C&quot;.</p>
<h4><a class="header" href="#exponential-and-normal-distributions" id="exponential-and-normal-distributions">Exponential and Normal distributions</a></h4>
<p>The main <code>Exp</code> and <code>Normal</code> distributions are unchanged, however the
&quot;standard&quot; versions, <code>Exp1</code> and <code>StandardNormal</code> are no longer wrapper types,
but full distributions. Instead of writing <code>let Exp1(x) = rng.gen();</code> you now
write <code>let x = rng.sample(Exp1);</code>.</p>
<h1><a class="header" href="#updating-to-06" id="updating-to-06">Updating to 0.6</a></h1>
<p>During the 0.6 cycle, Rand found a new home under the
<a href="https://github.com/rust-random">rust-random</a> project. We already feel at home,
but if you'd like to help us decorate, a <a href="https://github.com/rust-random/rand/issues/278">new logo</a> would be appreciated!</p>
<p>We also found a new home for user-centric documentation — this book!</p>
<h2><a class="header" href="#prngs-1" id="prngs-1">PRNGs</a></h2>
<p>All PRNGs in our <a href="https://docs.rs/rand/0.5/rand/prng/index.html">old PRNG module</a>
have been moved to new crates. We also added an additional crate with the PCG
algorithms, and an external crate with Xoshiro / Xoroshiro algorithms:</p>
<ul>
<li><a href="https://crates.io/crates/rand_chacha"><code>rand_chacha</code></a></li>
<li><a href="https://crates.io/crates/rand_hc"><code>rand_hc</code></a></li>
<li><a href="https://crates.io/crates/rand_isaac"><code>rand_isaac</code></a></li>
<li><a href="https://crates.io/crates/rand_xorshift"><code>rand_xorshift</code></a></li>
<li><a href="https://crates.io/crates/rand_pcg"><code>rand_pcg</code></a></li>
<li><a href="https://crates.io/crates/xoshiro"><code>xoshiro</code></a></li>
</ul>
<h3><a class="header" href="#smallrng" id="smallrng">SmallRng</a></h3>
<p>This update, we switched the algorithm behind <a href="../rand/rand/rngs/struct.SmallRng.html"><code>SmallRng</code></a> from Xorshift to a
PCG algorithm (either <a href="../rand/rand_pcg/type.Pcg64Mcg.html"><code>Pcg64Mcg</code></a> aka XSL 128/64 MCG, or <a href="../rand/rand_pcg/type.Pcg32.html"><code>Pcg32</code></a> aka
XSH RR 64/32 LCG aka the standard PCG algorithm).</p>
<h2><a class="header" href="#sequences-1" id="sequences-1">Sequences</a></h2>
<p>The <a href="../rand/rand/seq/index.html"><code>seq</code> module</a> has been completely re-written,
and the <code>choose</code> and <code>shuffle</code> methods have been removed from the <a href="../rand/trait.Rng.html"><code>Rng</code></a> trait.
Most functionality can now be found in the <a href="../rand/rand/seq/trait.IteratorRandom.html"><code>IteratorRandom</code></a> and
<a href="../rand/rand/seq/trait.SliceRandom.html"><code>SliceRandom</code></a> traits.</p>
<h3><a class="header" href="#weighted-choices" id="weighted-choices">Weighted choices</a></h3>
<p>The <a href="https://docs.rs/rand/0.5/rand/distributions/struct.WeightedChoice.html"><code>WeightedChoice</code></a> distribution has now been replaced with
<a href="../rand/rand/distributions/struct.WeightedIndex.html"><code>WeightedIndex</code></a>, solving a few issues by making the functionality more
generic.</p>
<p>For convenience, the <a href="../rand/rand/seq/trait.SliceRandom.html#tymethod.choose_weighted"><code>SliceRandom::choose_weighted</code></a> method (and <code>_mut</code>
variant) allow a <a href="../rand/rand/distributions/struct.WeightedIndex.html"><code>WeightedIndex</code></a> sample to be applied directly to a slice.</p>
<h2><a class="header" href="#other-features" id="other-features">Other features</a></h2>
<h3><a class="header" href="#simd-types" id="simd-types">SIMD types</a></h3>
<p>Rand now has rudimentary support for generating SIMD types, gated behind the
<code>simd_support</code> feature flag.</p>
<h3><a class="header" href="#i128--u128-types" id="i128--u128-types"><code>i128</code> / <code>u128</code> types</a></h3>
<p>Since these types are now available on stable compilers, these types are
supported automatically (with recent enough Rust version). The <code>i128_support</code>
feature flag still exists to avoid breakage, but no longer does anything.</p>
<h1><a class="header" href="#updating-to-07" id="updating-to-07">Updating to 0.7</a></h1>
<p>Since the 0.6 release, <a href="https://github.com/rust-random">rust-random</a>
gained a logo and a new crate: <a href="https://github.com/rust-random/getrandom">getrandom</a>!</p>
<h2><a class="header" href="#dependencies" id="dependencies">Dependencies</a></h2>
<p>Rand crates now require <code>rustc</code> version 1.32.0 or later.
This allowed us to remove all <code>build.rs</code> files for faster compilation.</p>
<p>The Rand crate now has fewer dependencies overall, though
with some new ones.</p>
<h2><a class="header" href="#getrandom-1" id="getrandom-1">Getrandom</a></h2>
<p>As mentioned above, we have a new crate: <a href="https://github.com/rust-random/getrandom">getrandom</a>, delivering a minimal API
around platform-independent access to fresh entropy. This replaces the previous
implementation in [<code>OsRng</code>], which is now merely a wrapper.</p>
<h2><a class="header" href="#core-features" id="core-features">Core features</a></h2>
<p>The <a href="https://docs.rs/rand/0.6.0/rand/trait.FromEntropy.html"><code>FromEntropy</code></a> trait has now been removed. Fear not though, its
<a href="https://rust-random.github.io/rand/rand/trait.SeedableRng.html#method.from_entropy"><code>from_entropy</code></a> method continues to provide easy initialisation from its new
home in the <a href="https://rust-random.github.io/rand/rand/trait.SeedableRng.html"><code>SeedableRng</code></a> trait (this requires that <code>rand_core</code> has the <code>std</code>
or <code>getrandom</code> feature enabled):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rand::{SeedableRng, rngs::StdRng};
let mut rng = StdRng::from_entropy();
<span class="boring">}
</span></code></pre></pre>
<p>The <a href="https://rust-random.github.io/rand/rand/trait.SeedableRng.html#method.from_rng"><code>SeedableRng::from_rng</code></a> method is now considered value-stable:
implementations should have portable results.</p>
<p>The <a href="https://rust-random.github.io/rand/rand_core/struct.Error.html"><code>Error</code></a> type of <code>rand_core</code> and <code>rand</code> has seen a major redesign; direct
usage of this type is likely to need adjustment.</p>
<h2><a class="header" href="#prngs-2" id="prngs-2">PRNGs</a></h2>
<p>These have seen less change than in the previous release, but noteworthy is:</p>
<ul>
<li><a href="https://crates.io/crates/rand_chacha"><code>rand_chacha</code></a> has been rewritten
for much better performance (via SIMD instructions)</li>
<li><a href="../rand/rand/rngs/struct.StdRng.html"><code>StdRng</code></a> and <a href="../rand/rand/rngs/struct.ThreadRng.html"><code>ThreadRng</code></a> now use the ChaCha algorithm. This is a
value-breaking change for <a href="../rand/rand/rngs/struct.StdRng.html"><code>StdRng</code></a>.</li>
<li><a href="../rand/rand/rngs/struct.SmallRng.html"><code>SmallRng</code></a> is now gated behind the <code>small_rng</code> feature flag.</li>
<li>The <code>xoshiro</code> crate is now <a href="https://crates.io/crates/rand_xoshiro"><code>rand_xoshiro</code></a>.</li>
<li><code>rand_pcg</code> now includes <a href="../rand/rand_pcg/type.Pcg64.html"><code>Pcg64</code></a>.</li>
</ul>
<h2><a class="header" href="#distributions-2" id="distributions-2">Distributions</a></h2>
<p>For the most widely used distributions (<a href="../rand/rand/distributions/struct.Standard.html"><code>Standard</code></a> and <a href="../rand/rand/distributions/struct.Uniform.html"><code>Uniform</code></a>), there have
been no significant changes. But for <em>most</em> of the rest...</p>
<ul>
<li>We added a new crate, [rand_distr], to house the all distributions
(including re-exporting those still within <a href="../rand/rand/distributions/index.html"><code>rand::distributions</code></a>). If you
previously used <a href="../rand/rand/distributions/struct.Normal.html"><code>rand::distributions::Normal</code></a>, now you use
<a href="../rand/rand_distr/struct.Normal.html"><code>rand_distr::Normal</code></a>.</li>
<li>Constructors for many distributions changed in order to return a <code>Result</code>
instead of panicking on error.</li>
<li>Many distributions are now generic over their parameter type (in most cases
supporting <code>f32</code> and <code>f64</code>). This aids usage with generic code, and allows
reduced size of parameterised distributions. Currently the more complex
algorithms always use <code>f64</code> internally.</li>
<li><a href="../rand/rand/distributions/struct.Standard.html"><code>Standard</code></a> can now sample <a href="https://doc.rust-lang.org/std/num/index.html"><code>NonZeroU*</code></a> values</li>
</ul>
<p>We also added several distributions:</p>
<ul>
<li><a href="../rand/rand/distributions/alias_method/struct.WeightedIndex.html"><code>rand::distributions::weighted::alias_method::WeightedIndex</code></a></li>
<li><a href="../rand/rand_distr/struct.Pert.html"><code>rand_distr::Pert</code></a></li>
<li><a href="../rand/rand_distr/struct.Triangular.html"><code>rand_distr::Triangular</code></a></li>
<li><a href="../rand/rand_distr/struct.UnitBall.html"><code>rand_distr::UnitBall</code></a></li>
<li><a href="../rand/rand_distr/struct.UnitDisc.html"><code>rand_distr::UnitDisc</code></a></li>
<li><a href="../rand/rand_distr/struct.UnitSphere.html"><code>rand_distr::UnitSphere</code></a> (previously named <code>rand::distributions::UnitSphereSurface</code>)</li>
</ul>
<h2><a class="header" href="#sequences-2" id="sequences-2">Sequences</a></h2>
<p>To aid portability, all random samples of type <code>usize</code> now instead sample a
<code>u32</code> value when the upper-bound is less than <code>u32::MAX</code>. This means that
upgrading to 0.7 is a value-breaking change for use of <code>seq</code> functionality, but
that after upgrading to 0.7 results should be consistent across CPU
architectures.</p>
<h1><a class="header" href="#updating-to-08" id="updating-to-08">Updating to 0.8</a></h1>
<p>In the following, instructions are provided for porting your code from
<code>rand 0.7</code> and <code>rand_distr 0.2</code> to <code>rand 0.8</code> and <code>rand_distr 0.3</code>.</p>
<h2><a class="header" href="#dependencies-1" id="dependencies-1">Dependencies</a></h2>
<p>Rand crates now require <strong><code>rustc</code></strong> version 1.36.0 or later.
This allowed us to remove some unsafe code and simplify the internal <code>cfg</code> logic.</p>
<p>The dependency on <strong><code>getrandom</code></strong> was bumped to version 0.2. While this does not
affect Rand's API, you may be affected by some of the breaking changes even if
you use <code>getrandom</code> only as a dependency:</p>
<ul>
<li>You may have to update the <code>getrandom</code> features you are using. The
following features are now available:
<ul>
<li><code>&quot;rdrand&quot;</code>: Use the RDRAND instruction on <code>no_std</code> <code>x86/x86_64</code>
targets.</li>
<li><code>&quot;js&quot;</code>: Use JavaScript calls on <code>wasm32-unknown-unknown</code>. This
replaces the <code>stdweb</code> and <code>wasm-bindgen</code> features, which are
removed.</li>
<li><code>&quot;custom&quot;</code>: Allows you to specify a custom implementation.</li>
</ul>
</li>
<li>Unsupported targets no longer compile. If you require the previous behavior
(panicking at runtime instead of failing to compile), you can use the
<code>custom</code> feature to provide a panicking implementation.</li>
<li>Windows XP and stdweb are, as of <code>getrandom</code> version 0.2.1, no longer
supported. If you require support for either of these platforms you may add
a dependency on <code>getrandom = &quot;=0.2.0&quot;</code> to pin this version.</li>
<li>Hermit, L4Re and UEFI are no longer officially supported. You can use the
<code>rdrand</code> feature on these platforms.</li>
<li>The minimum supported Linux kernel version is now 2.6.32.</li>
</ul>
<p>If you are using <code>getrandom</code>'s API directly, there are further breaking changes
that may affect you. See its
<a href="https://github.com/rust-random/getrandom/blob/master/CHANGELOG.md#020---2020-09-10">changelog</a>.</p>
<p><a href="https://serde.rs/">Serde</a> has been re-added as an optional dependency (use the <code>serde1</code> feature
flag), supporting many types (where appropriate). <code>StdRng</code> and <code>SmallRng</code> are
deliberately excluded since these types are not portable.</p>
<h2><a class="header" href="#core-features-1" id="core-features-1">Core features</a></h2>
<h4><a class="header" href="#threadrng" id="threadrng"><code>ThreadRng</code></a></h4>
<p><code>ThreadRng</code> no longer implements <code>Copy</code>. This was necessary to fix a possible
use-after-free in its thread-local destructor. Any code relying on <code>ThreadRng</code>
being copied must be updated to use a mutable reference instead. For example,</p>
<pre><code>let rng = thread_rng();
let a: u32 = Standard.sample(rng);
let b: u32 = Standard.sample(rng);
</code></pre>
<p>can be replaced with the following code:</p>
<pre><code>let mut rng = thread_rng();
let a: u32 = Standard.sample(&amp;mut rng);
let b: u32 = Standard.sample(&amp;mut rng);
</code></pre>
<h4><a class="header" href="#gen_range" id="gen_range"><code>gen_range</code></a></h4>
<p><a href="../rand/rand/trait.Rng.html#method.gen_range"><code>Rng::gen_range</code></a> now takes a <code>Range</code> instead of two numbers. Thus, replace
<code>gen_range(a, b)</code> with <code>gen_range(a..b)</code>. We suggest using the following regular
expression to search-replace in all files:</p>
<ul>
<li>replace <code>gen_range\(([^,]*),\s*([^)]*)\)</code></li>
<li>with <code>gen_range(\1..\2)</code></li>
<li>or with <code>gen_range($1..$2)</code> (if your tool does not support backreferences)</li>
</ul>
<p>Most IDEs support search-replace-across-files or similar; alternatively an
external tool such as Regexxer may be used.</p>
<p>This change has a couple of other implications:</p>
<ul>
<li>inclusive ranges are now supported, e.g. <code>gen_range(1..=6)</code> or <code>gen_range('A'..='Z')</code></li>
<li>it may be necessary to explicitly dereference some parameters</li>
<li>SIMD types are no longer supported (<code>Uniform</code> types may still be used directly)</li>
</ul>
<h4><a class="header" href="#fill" id="fill"><code>fill</code></a></h4>
<p>The <code>AsByteSliceMut</code> trait was replaced with the <a href="../rand/rand/trait.Fill.html"><code>Fill</code></a> trait. This should
only affect code implementing <code>AsByteSliceMut</code> on user-defined types, since the
<a href="../rand/rand/trait.Rng.html#method.fill"><code>Rng::fill</code></a> and <a href="../rand/rand/trait.Rng.html#method.try_fill"><code>Rng::try_fill</code></a> retain support for previously-supported types.</p>
<p><code>Fill</code> supports some additional slice types which could not be supported with
<code>AsByteSliceMut</code>: <code>[bool], [char], [f32], [f64]</code>.</p>
<h4><a class="header" href="#adapter" id="adapter"><code>adapter</code></a></h4>
<p>The entire [<code>rand::rngs::adapter</code>] module is now restricted to the <code>std</code> feature.
While this is technically a breaking change, it should only affect <code>no_std</code> code
using <a href="../rand/rand/rngs/adapter/struct.ReseedingRng.html"><code>ReseedingRng</code></a>, which is unlikely to exist in the wild.</p>
<h2><a class="header" href="#generators" id="generators">Generators</a></h2>
<p><strong>StdRng</strong> has switched from the 20-round ChaCha20 to ChaCha12 for improved
performance. This is a reduction in complexity but the 12-round variant is still
considered secure: see <a href="https://github.com/rust-random/rand/issues/932">rand#932</a>. This is a value-breaking change for <code>StdRng</code>.</p>
<p><strong>SmallRng</strong> now uses the Xoshiro128++ and Xoshiro256++ algorithm on 32-bit
and 64-bit platforms respectively. This reduces correlations of random data
generated from similar seeds and improves performance. It is a value-breaking
change.</p>
<p>We now implement <code>PartialEq</code> and <code>Eq</code> for <a href="../rand/rand/rngs/struct.StdRng.html"><code>StdRng</code></a>, <a href="../rand/rand/rngs/struct.SmallRng.html"><code>SmallRng</code></a>, and <a href="../rand/rand/rngs/struct.StepRng.html"><code>StepRng</code></a>.</p>
<h2><a class="header" href="#distributions-3" id="distributions-3">Distributions</a></h2>
<p>Several smaller changes occurred to rand distributions:</p>
<ul>
<li>The <a href="../rand/rand/distributions/struct.Uniform.html"><code>Uniform</code></a> distribution now additionally supports the <code>char</code> type, so
for example <code>rng.gen_range('a'..='f')</code> is now supported.</li>
<li><a href="../rand/rand/distributions/uniform/trait.UniformSampler.html#method.sample_single_inclusive"><code>UniformSampler::sample_single_inclusive</code></a> was added.</li>
<li>The <a href="../rand/rand/distributions/struct.Alphanumeric.html"><code>Alphanumeric</code></a> distribution now samples bytes instead of chars. This
more closely reflects the internally used type, but old code likely has to
be adapted to perform the conversion from <code>u8</code> to <code>char</code>. For example, with
Rand 0.7 you could write:
<pre><code>let chars: String = iter::repeat(())
    .map(|()| rng.sample(Alphanumeric))
    .take(7)
    .collect();
</code></pre>
With Rand 0.8, this is equivalent to the following:
<pre><code>let chars: String = iter::repeat(())
    .map(|()| rng.sample(Alphanumeric))
    .map(char::from)
    .take(7)
    .collect();
</code></pre>
</li>
<li>The alternative implementation of <a href="../rand/rand/distributions/struct.WeightedIndex.html"><code>WeightedIndex</code></a> employing the alias
method was moved from <code>rand</code> to <a href="../rand/rand_distr/struct.WeightedAliasIndex.html"><code>rand_distr::WeightedAliasIndex</code></a>. The
alias method is faster for large sizes, but it suffers from a slow
initialization, making it less generally useful.</li>
</ul>
<p>In <code>rand_distr</code> v0.4, more changes occurred (since v0.2):</p>
<ul>
<li><a href="../rand/rand_distr/struct.WeightedAliasIndex.html"><code>rand_distr::WeightedAliasIndex</code></a> was added (moved from the <code>rand</code> crate)</li>
<li><a href="../rand/rand_distr/struct.InverseGaussian.html"><code>rand_distr::InverseGaussian</code></a> and <a href="../rand/rand_distr/struct.NormalInverseGaussian.html"><code>rand_distr::NormalInverseGaussian</code></a>
were added</li>
<li>The <a href="../rand/rand_distr/struct.Geometric.html"><code>Geometric</code></a> and <a href="../rand/rand_distr/struct.Hypergeometric.html"><code>Hypergeometric</code></a> distributions are now supported.</li>
<li>A different algorithm is used for the <a href="../rand/rand_distr/struct.Beta.html"><code>Beta</code></a> distribution, improving both
performance and accuracy. This is a value-breaking change.</li>
<li>The <a href="../rand/rand_distr/struct.Normal.html"><code>Normal</code></a> and <a href="../rand/rand_distr/struct.LogNormal.html"><code>LogNormal</code></a> distributions now support a <code>from_mean_cv</code>
constructor method and <code>from_zscore</code> sampler method.</li>
<li><a href="../rand/rand_distr/struct.Dirichlet.html"><code>rand_distr::Dirichlet</code></a> now uses boxed slices internally instead of <code>Vec</code>.
Therefore, the weights are taken as a slice instead of a <code>Vec</code> as input.
For example, the following <code>rand_distr 0.2</code> code
<pre><code>Dirichlet::new(vec![1.0, 2.0, 3.0]).unwrap();
</code></pre>
can be replaced with the following <code>rand_distr 0.3</code> code:
<pre><code>Dirichlet::new(&amp;[1.0, 2.0, 3.0]).unwrap();
</code></pre>
</li>
<li><a href="../rand/rand_distr/struct.Poisson.html"><code>rand_distr::Poisson</code></a> does no longer support sampling <code>u64</code> values directly.
Old code may have to be updated to perform the conversion from <code>f64</code>
explicitly.</li>
<li>The custom <code>Float</code> trait in <code>rand_distr</code> was replaced with
<code>num_traits::Float</code>. Any implementations of <code>Float</code> for user-defined types
have to be migrated. Thanks to the math functions from <code>num_traits::Float</code>,
<code>rand_distr</code> now supports <code>no_std</code>.</li>
</ul>
<p>Additonally, there were some minor improvements:</p>
<ul>
<li>The treatment of rounding errors and NaN was improved for the
<a href="../rand/rand/distributions/struct.WeightedIndex.html"><code>WeightedIndex</code></a> distribution.</li>
<li>The <a href="../rand/rand_distr/struct.Exp.html"><code>rand_distr::Exp</code></a> distribution now supports the <code>lambda = 0</code> parametrization.</li>
</ul>
<h2><a class="header" href="#sequences-3" id="sequences-3">Sequences</a></h2>
<p>Weighted sampling without replacement is now supported, see
<a href="../rand/rand/seq/index/fn.sample_weighted.html"><code>rand::seq::index::sample_weighted</code></a> and
<a href="../rand/rand/seq/trait.SliceRandom.html#method.choose_multiple_weighted"><code>SliceRandom::choose_multiple_weighted</code></a>.</p>
<p>There have been <a href="https://github.com/rust-random/rand/pull/1059">value-breaking
changes</a> to
<a href="../rand/rand/seq/trait.IteratorRandom.html#method.choose"><code>IteratorRandom::choose</code></a>, improving accuracy and performance. Furthermore,
<a href="../rand/rand/seq/trait.IteratorRandom.html#method.choose_stable"><code>IteratorRandom::choose_stable</code></a> was added to provide an alternative that
sacrifices performance for independence of iterator size hints.</p>
<h2><a class="header" href="#feature-flags-2" id="feature-flags-2">Feature flags</a></h2>
<p><code>StdRng</code> is now gated behind a new feature flag, <code>std_rng</code>. This is enabled by
default.</p>
<p>The <code>nightly</code> feature no longer implies the <code>simd_support</code> feature. If you were
relying on this for SIMD support, you will have to use <code>simd_support</code> feature
directly.</p>
<h2><a class="header" href="#tests" id="tests">Tests</a></h2>
<p>Value-stability tests were added for all distributions (<a href="https://github.com/rust-random/rand/issues/786">rand#786</a>), helping
enforce our rules regarding value-breaking changes (see <a href="./portability.html">Portability</a> section).</p>
<h1><a class="header" href="#contributing" id="contributing">Contributing</a></h1>
<p>Thank you for your interest in contributing to Rand!</p>
<p>We are open to all contributors, but please consider that we have limited
resources, usually have other on-going work within the project, and that even
accepting complete PRs costs us time (review and potentially on-going support),
thus we may take considerable time to get back to you.</p>
<h2><a class="header" href="#all-contributions" id="all-contributions">All contributions</a></h2>
<ul>
<li>
<p><strong>Scope:</strong> please consider whether your &quot;issue&quot; falls within the existing
scope of the project or is an enhancement. Note that whether something is
considered a <em>defect</em> may depend on your point of view. We may choose to
reject contributions to avoid increasing our workload.</p>
<p>If you wish to expand the scope of the project (e.g. new platforms or
additional CI testing) then please be prepared to provide on-going
support.</p>
</li>
<li>
<p><strong>Fixes:</strong> if you can easily fix this yourself, please consider making a PR
instead of opening an issue. On the other hand if it's less easy or looks
like it may conflict with other work, don't hesistate to open an issue.</p>
</li>
</ul>
<h2><a class="header" href="#pull-requests" id="pull-requests">Pull Requests</a></h2>
<ul>
<li>
<p><strong>Changelog:</strong> unless your change is trivial, please include a note in the
changelog (<code>CHANGELOG.md</code>) of each crate affected, under the <code>[Unreleased]</code>
heading at the top (add if necessary). Please include the PR number (this
implies the note must be added <em>after</em> opening a PR).</p>
</li>
<li>
<p><strong>Commits:</strong> if contributing large changes, consider splitting these over
multiple commits, if possible such that each commit at least compiles.
Rebasing commits may be appropriate when making significant changes.</p>
</li>
<li>
<p><strong>Documentation:</strong> we require documentation of all public items. Short
examples may be included where appropriate.</p>
</li>
<li>
<p><strong>Maintainability:</strong> it is important to us that code is easy to read and
understand and not hard to review for correctness.</p>
</li>
<li>
<p><strong>Performance:</strong> we always aim for good performance and sometimes do
considerable extra work to get there, however we must also make compromises
for the sake of maintainability, and consider whether a minor efficiency
gain is worth the extra code complexity. <a href="contrib-bench.html">Use benchmarks</a>.</p>
</li>
<li>
<p><strong>Style:</strong> make it neat. <em>Usually</em> limit length to 80 chars.</p>
</li>
<li>
<p><strong>Unsafe:</strong> use it where necessary, not if there is a good alternative.
Ensure <code>unsafe</code> code is easy to review for correctness.</p>
</li>
<li>
<p><strong>License and attribution:</strong> this project is freely licenced under the MIT
and Apache Public Licence v2. We assume that all contributions are made
under these licence grants. Copyrights are retained by their contributors.</p>
<p>Our works are attributed to &quot;The Rand Project Developers&quot;. This is not a
formal entity but merely the collection of all contributors to this project.
For more, see the <a href="COPYRIGHT">COPYRIGHT</a> file.</p>
</li>
<li>
<p><strong>Thank you!</strong></p>
</li>
</ul>
<h1><a class="header" href="#documentation" id="documentation">Documentation</a></h1>
<h3><a class="header" href="#style" id="style">Style</a></h3>
<p>All documentation is in English, but no particular dialect is preferred.</p>
<p>The documentation should be accessible to multiple audiences: both seasoned
Rustaceans and relative newcomers, those with experience in statistical
modelling or cryptography, as well as those new to the subjects. Since it is
often impossible to write appropriate one-size-fits-all documentation, we
prefer concise technical documentation with reference to extended articles
aimed at more specific audiences.</p>
<h2><a class="header" href="#api-documentation" id="api-documentation">API documentation</a></h2>
<h3><a class="header" href="#rand-crates" id="rand-crates">Rand crates</a></h3>
<p>It is recommended to use nightly Rust for correct link handling.</p>
<p>To build all API documentation for all crates in the
<a href="https://github.com/rust-random/rand">rust-random/rand</a> repository, run:</p>
<pre><code class="language-sh"># Build doc for all modules:
cargo doc --all --no-deps

# And open it:
xdg-open target/doc/rand/index.html
</code></pre>
<p>On Linux, it is easy to set up automatic rebuilds after any edit:</p>
<pre><code class="language-sh">while inotifywait -r -e close_write src/ rand_*/; do cargo doc; done
</code></pre>
<p>After editing API documentation, we reccomend testing examples and
checking for broken links:</p>
<pre><code class="language-sh">cargo test --doc

cargo install cargo-deadlinks
# It is recommended to remove left-over files from previous compilations
rm -rf /target/doc
cargo doc --all --no-deps
cargo deadlinks --dir target/doc
</code></pre>
<p>Rand API docs are automatically built and hosted at
<a href="https://rust-random.github.io/rand">rust-random.github.io/rand</a> for the latest code in master.</p>
<h3><a class="header" href="#getrandom-crate" id="getrandom-crate">Getrandom crate</a></h3>
<p>The <a href="https://github.com/rust-random/getrandom">rust-random/getrandom</a>
repository contains only a single crate, hence a simple <code>cargo doc</code> will
suffice.</p>
<h3><a class="header" href="#cross-crate-links" id="cross-crate-links">Cross-crate links</a></h3>
<p>When referring to another crate, we prefer linking to the crate page on
crates.io since (a) this includes the README documenting the purpose of the
crate and (b) this links directly to both the repository and the API
documentation. Example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Link to the crate page:
//! [`rand_chacha`]: https://crates.io/crates/rand_chacha
<span class="boring">}
</span></code></pre></pre>
<p>When referring to an item from within another crate,</p>
<ol>
<li>if that item is accessible via a crate dependency (even if not via the
public API), use the Rust item path</li>
<li>when linking to another crate within the <code>rust-random/rand</code> repository,
relative paths within the generated documentation files (under <code>target/doc</code>)
can be used; these work on <a href="https://rust-random.github.io/rand">rust-random.github.io/rand</a> but not
currently on <code>docs.rs</code> (see <a href="https://github.com/rust-lang/docs.rs/issues/204">docs#204</a>)</li>
<li>if neither of the above are applicable, use an absolute link</li>
<li>consider revising documentation, e.g. refer to the crate instead</li>
</ol>
<p>Examples:</p>
<pre><code>// We depend on rand_core, therefore can use the Rust path:
/// [`BlockRngCore`]: rand_core::block::BlockRngCore

// rand_chacha is not a dependency, but is within the same repository:
//! [`ChaCha20Rng`]: ../../rand_chacha/struct.ChaCha20Rng.html

// Link directly to docs.rs, with major &amp; minor but no patch version:
https://docs.rs/getrandom/0.1/getrandom/fn.getrandom.html
</code></pre>
<h2><a class="header" href="#auxilliary-documentation" id="auxilliary-documentation">Auxilliary documentation</a></h2>
<h3><a class="header" href="#readme-files" id="readme-files">README files</a></h3>
<p>README files contain a brief introduction to the crate, shield badges, useful
links, feature-flag documentation, licence information, and potentially an
example.</p>
<p>For the most part these files do not have any continuous testing.
Where examples are included (currently only for the <code>rand_jitter</code> crate),
we enable continuous testing via <code>doc_comment</code> (see
<a href="https://github.com/rust-random/rand/blob/master/rand_jitter/src/lib.rs#L62">lib.rs:62 onwards</a>).</p>
<h3><a class="header" href="#changelog-files" id="changelog-files">CHANGELOG files</a></h3>
<p>Changelog formats are based on the
<a href="http://keepachangelog.com/en/1.0.0/">Keep a Changelog</a> format.</p>
<p>All significant changes merged since the last release should be listed under an
<code>[Unreleased]</code> section at the top of log.</p>
<h3><a class="header" href="#the-book" id="the-book">The book</a></h3>
<p>The source to this book is contained in the
<a href="https://github.com/rust-random/book">rust-random/book</a> repository.
It is built using mdbook, which makes building and testing easy:</p>
<pre><code class="language-sh">cargo install mdbook --version &quot;^0.2&quot;

mdbook build --open
mdbook test

# To automatically rebuild after any changes:
mdbook watch
</code></pre>
<p>Note that links in the book are relative and designed to work in the
<a href="https://rust-random.github.io/book/">published book</a>. If you build the book
locally, you might want to set up a symbolic link pointing to your build of the
API documentation:</p>
<pre><code class="language-sh">ln -s ../rand/target/doc rand
</code></pre>
<h1><a class="header" href="#scope" id="scope">Scope</a></h1>
<p>Over time, the scope of the project has grown, and Rand has moved from using a
monolithic crate to using a &quot;main&quot; crate plus multiple single-purpose crates.
For new functionality, one must consider where, and whether, it fits within the
Rand project.</p>
<p>Small, focussed crates may be used for a few reasons, but we aim <em>not</em> to
maximally divide functionality into small crates. Valid reasons for using a
separate crate for a feature are therefore:</p>
<ul>
<li>to allow a clear dependency hierarchy (<code>rand_core</code>)</li>
<li>to make the feature available in a stand-alone fashion (e.g. <code>getrandom</code>)</li>
<li>to remove little-used features with non-trivial amounts of code from widely
used crates (e.g. <code>rand_jitter</code> and <code>rand_distr</code> both extracted
functionality from <code>rand</code>)</li>
<li>to allow choice, without including large amounts of unused code for all
users, but also without producing an enormous number of new crates
(RNG family crates like <code>rand_xoshiro</code> and <code>rand_isaac</code>)</li>
</ul>
<h2><a class="header" href="#traits-basics-and-ui" id="traits-basics-and-ui">Traits, basics and UI</a></h2>
<p>The main user interface to the Rand project remains the central <code>rand</code> crate.
Goals for this crate are:</p>
<ul>
<li>ease of use</li>
<li>expose commonly used functionality in a single place</li>
<li>permit usage of additional randomness sources and distribution samplers</li>
</ul>
<p>To allow better modularity, the core traits have been moved to the <code>rand_core</code>
crate. Goals of this crate are:</p>
<ul>
<li>expose the core traits with minimal dependencies</li>
<li>provide common tools needed to implement various randomness sources</li>
</ul>
<h2><a class="header" href="#external-random-sources" id="external-random-sources">External random sources</a></h2>
<p>The main (and usually only) external source of randomness is the Operating
System, interfaced via the <code>getrandom</code> crate. This crate also supports usage of
RDRAND on a few <code>no_std</code> targets.</p>
<p>Support for other <code>no_std</code> targets has been discussed but with little real
implementation effort. See
<a href="https://github.com/rust-random/getrandom/issues/4">getrandom#4</a>.</p>
<p>The <code>rand_jitter</code> crate provides an implementation of a
<a href="http://www.chronox.de/jent.html">CPU Jitter</a> entropy harvestor, and is only
included in Rand for historical reasons.</p>
<p>The <code>rand_os</code> crate proves an <code>RngCore</code> implementation around <code>getrandom</code>.</p>
<h2><a class="header" href="#pseudo-random-generators" id="pseudo-random-generators">Pseudo-random generators</a></h2>
<p>The Rand library includes several pseudo-random number generators, for the
following reasons:</p>
<ul>
<li>to implement the <code>StdRng</code> and <code>SmallRng</code> generators</li>
<li>to provide a few high-quality alternative generators</li>
<li>historical usage</li>
</ul>
<p>These are implemented within &quot;family&quot; crates, e.g. <code>rand_chacha</code>, <code>rand_pcg</code>,
<code>rand_xoshiro</code>.</p>
<p>We have received several requests to adopt new algorithms into the library; when
evaluating such requests we must consider several things:</p>
<ul>
<li>purpose for inclusion within Rand</li>
<li>whether the PRNG is cryptographically secure, and if so, how trustworthy
such claims are</li>
<li>statistical quality of output</li>
<li>performance and features of the generator</li>
<li>reception and third-party review of the algorithm</li>
</ul>
<h2><a class="header" href="#distributions-4" id="distributions-4">Distributions</a></h2>
<p>The <code>Distribution</code> trait is provided by Rand, along with commonly-used
distributions (mostly linear ones).</p>
<p>Additional distributions are packaged within the <code>rand_distr</code> crate, which
depends on <code>rand</code> and re-exports all of its distributions.</p>
<h1><a class="header" href="#testing-1" id="testing-1">Testing</a></h1>
<p>Rand has a number of unit tests, though these are not comprehensive or perfect
(improvements welcome). We prefer to have tests for all new functionality.</p>
<p>The first line of testing is simply to run <code>cargo test</code> from the appropriate
directory. Since Rand supports <code>no_std</code> (core-only), <code>core+alloc</code> and <code>std</code>
environments, it is important to test all three (depending on which features
are applicable to the code in question):</p>
<pre><code class="language-sh"># Test using std:
cargo test
# Test using only core:
cargo test --tests --no-default-features
# Test using core + alloc (requires nightly):
cargo +nightly test --tests --no-default-features --features=alloc
</code></pre>
<p>It may also be worth testing with other feature flags:</p>
<pre><code class="language-sh">cargo test --all-features
</code></pre>
<p>Note that this only tests the current package (i.e. the main Rand lib when run
from the repo's top level). To test another lib, <code>cd</code> to its directory.</p>
<p>We do not recommend using Cargo's <code>--package</code> option due to its 
<a href="https://github.com/rust-lang/cargo/issues/5364">surprising interactions</a>
with <code>--feature</code> options and failure when multiple versions of the same package
are in the build tree. The CI instead uses <code>--manifest-path</code> to select packages;
while developing, using <code>cd</code> is easier.</p>
<h2><a class="header" href="#writing-tests" id="writing-tests">Writing tests</a></h2>
<p>Tests may be unit tests within a <code>test</code> sub-module, documentation examples,
example applications (<code>examples</code> dir), integration tests (<code>tests</code> dir), or
benchmarks (<code>benches</code> dir).</p>
<p>Note that <em>only</em> unit tests and integration tests are expected to pass in
<code>no_std</code> (core only) and <code>core+alloc</code> configurations. This is a deliberate
choice; example code should only need to target the common case (<code>std</code>).</p>
<h3><a class="header" href="#random-number-generators" id="random-number-generators">Random Number Generators</a></h3>
<p>Often test code needs some RNG to test with, but does not need any particular
RNG. In this case, we prefer use of <code>::test::rng</code> which is simple, fast to
initialise and deterministic:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut rng = ::test::rng(528); // just pick some number
<span class="boring">}
</span></code></pre></pre>
<p>Various tests concern properties which are <em>probably</em> true, but not definitely.
We prefer that such tests are deterministic to avoid spurious failures.</p>
<h1><a class="header" href="#benchmarks" id="benchmarks">Benchmarks</a></h1>
<p>We already have many benchmarks:</p>
<pre><code class="language-sh">cargo +nightly bench

# In a few cases, nightly features may use different code paths:
cargo +nightly bench --features=nightly
</code></pre>
<p>Benchmarks for distributions now live in the <code>rand_distr</code> crate; all other
benchmarks (including all our RNGs) live in the main <code>rand</code> crate
(hence the many dev-dependencies).</p>
<p>A lot of code in Rand is performance sensitive, most of it is expected to be
used in hot loops in some libraries/applications. If you change code in
<code>rand_core</code>, in PRNG crates, or in the <code>rngs</code> or <code>distributions</code> modules
(especially when an 'obvious cleanup'), make sure the benchmarks do not regress.</p>
<p>Please report before-and-after results for any affected benchmarks. If you are
optimising something previously not benchmarked, please add new benchmarks
first, then add your changes in a separate commit (to make before-and-after
benchmarking easy).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
